# C++教程
- [初级](#1)
- [中级](#2)
- [高级](#3)


参考链接  
1.C/C++ 技术面试基础知识总结  
https://github.com/huihut/interview  

## <a id="1">初级</a>
- [写代码容易忽视的编译报错](#1.0)
- [const + static + extern](#1.1)
- [this指针](#1.2)
- [inline内联函数](#1.3)
- [volatile](#1.4)
- [assert](#1.5)
- [sizeof + pragma pack + 位域](#1.6)
- [struct和typedef struct](#1.7)
- [struct和class和union](#1.8)
- [using+范围解析运算符](#1.9)
- [宏](#1.10)
- [成员初始化列表](#1.11)
- [内存分配和管理](#1.12)

### <a id="1.0">写代码容易忽视的编译报错</a>
1. class eum struct大括号后面要加分号。   
2. 链接报错，修改cmake顺序，越基础越在后面。

### <a id="1.1">const + static + extern</a>
#### 1.const
##### 作用
1. 修饰变量，说明该变量不可以被改变；
2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；
3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；
4. `修饰成员函数，说明该成员函数内不能修改成员变量`。

##### const 的指针与引用
* 指针
 * 指向常量的指针（pointer to const）
 * 自身是常量的指针（常量指针，const pointer）
* 引用
 * 指向常量的引用（reference to const）
 * 没有 const reference，因为引用本身就是 const pointer
（为了方便记忆可以想成）被 const 修饰（在 const 后面）的值不可改变，如下文使用例子中的 p2、p3

##### const使用
```cpp
// 类
class A
{
private:
    const int a;                // 常对象成员，只能在初始化列表赋值

public:
    // 构造函数
    A() : a(0) { };
    A(int x) : a(x) { };        // 初始化列表

    // const可用于对重载函数的区分
    int getValue();             // 普通成员函数
    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值
};

void function()
{
    // 对象
    A b;                        // 普通对象，可以调用全部成员函数、更新常成员变量
    const A a;                  // 常对象，只能调用常成员函数
    const A *p = &a;            // 指针变量，指向常对象
    const A &q = a;             // 指向常对象的引用

    // 指针
    char greeting[] = "Hello";
    char* p1 = greeting;                // 指针变量，指向字符数组变量
    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）
    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）
    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量
}

// 函数
void function1(const int Var);           // 传递过来的参数在函数内不可变
void function2(const char* Var);         // 参数指针所指内容为常量
void function3(char* const Var);         // 参数指针为常量
void function4(const int& Var);          // 引用参数在函数内为常量

// 函数返回值
const int function5();      // 返回一个常数
const int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();
int* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();
```

#### 2.static
##### 作用
1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。-----普通变量
2. 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。-----普通函数
3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。-----成员变量
4. `修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。`</font>-----成员函数

声明后和全局变量一样，和类进行绑定封装。使用需要定义和声明，需要初始化，否则使用没有对象没法使用。如果在非静态函数中使用static变量需要先定义对象。

#### 3.extern
##### 作用
* 被 extern 限定的函数或变量是 extern 类型的
* 被 `extern "C"` 修饰的变量和函数是按照 C 语言方式编译和链接的

`extern "C"` 的作用是让 C++ 编译器将 `extern "C"` 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。

extern "C" 使用

```cpp
#ifdef __cplusplus
extern "C" {
#endif

void *memset(void *, int, size_t);

#ifdef __cplusplus
}
#endif
```

### <a id="1.2">this指针</a>
1. `this`指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。
2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 `this` 指针。
3. 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
4. `this` 指针被隐含地声明为: ClassName *const this，这意味着不能给 `this` 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
5. `this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址（不能 &`this`）。
在以下场景中，经常需要显式引用 `this` 指针：
 * 为实现对象的链式引用；
 * 为避免对同一对象进行赋值操作；
 * 在实现一些数据结构时，如 list。

### <a id="1.3">inline内联函数</a>
#### 特征
* 相当于把内联函数里面的内容写在调用内联函数处；
* 相当于不用执行进入函数的步骤，直接执行函数体；
* `相当于宏，却比宏多了类型检查，真正具有函数特性`；
* 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
* `在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数`。

#### 使用
```cpp
// 声明1（加 inline，建议使用）
inline int functionName(int first, int second,...);

// 声明2（不加 inline）
int functionName(int first, int second,...);

// 定义
inline int functionName(int first, int second,...) {/****/};

// 类内定义，隐式内联
class A {
    int doA() { return 0; }         // 隐式内联
}

// 类外定义，需要显式内联
class A {
    int doA();
}
inline int A::doA() { return 0; }   // 需要显式内联
```

#### 编译器对 inline 函数的处理步骤
1. 将 inline 函数体复制到 inline 函数调用点处； 
2. 为所用 inline 函数中的局部变量分配内存空间； 
3. 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； 
4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。

#### 优缺点
优点  
1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
2. 内联函数相比宏函数来说，在代码展开时，`会做安全检查或自动类型转换（同普通函数），而宏定义则不会`。 
3. `在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能`。
4. `内联函数在运行时可调试，而宏定义不可以`。  

缺点  
1. 代码膨胀。`内联是以代码膨胀（复制）为代价，消除函数调用带来的开销`。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，`是否对函数内联，决定权在于编译器`。

#### 虚函数（virtual）可以是内联函数（inline）吗？
> [Are "inline virtual" member functions ever actually "inlined"?](http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html)

* 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
* `内联是在编译器建议编译器内联，而虚函数的多态性在运行期`，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
* `inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生`。

#### 虚函数内联使用
```cpp
#include <iostream>  
using namespace std;
class Base
{
public:
	inline virtual void who()
	{
		cout << "I am Base\n";
	}
	virtual ~Base() {}
};
class Derived : public Base
{
public:
	inline void who()  // 不写inline时隐式内联
	{
		cout << "I am Derived\n";
	}
};

int main()
{
	// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
	Base b;
	b.who();

	// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
	Base *ptr = new Derived();
	ptr->who();

	// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
	delete ptr;
	ptr = nullptr;

	system("pause");
	return 0;
} 
```

### <a id="1.4">volatile</a> 
#### 特征
* volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
* volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
* const 可以是 volatile （如只读的状态寄存器）
* 指针可以是 volatile
* 当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。

### <a id="1.5">assert</a>
#### 特征
断言，是宏，而非函数。assert 宏的原型定义在 `<assert.h>`（C）、`<cassert>`（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 `NDEBUG` 来关闭 assert，但是需要在源代码的开头，`include <assert.h>` 之前。  
#### assert() 使用
```cpp
#define NDEBUG          // 加上这行，则 assert 不可用
#include <assert.h>

assert( p != NULL );    // assert 不可用
```

### <a id="1.6">sizeof + pragma pack + 位域</a>
#### 1.sizeof特征
* sizeof 对数组，得到整个数组所占空间大小。
* sizeof 对指针，得到指针本身所占空间大小。

#### 2.pragma pack特征
设定结构体、联合以及类成员变量以 n 字节方式对齐

```cpp
#pragma pack(push)  // 保存对齐状态
#pragma pack(4)     // 设定为 4 字节对齐

struct test
{
    char m1;
    double m4;
    int m3;
};

#pragma pack(pop)   // 恢复对齐状态
```

#### 3.位域特征
```cpp
Bit mode: 2;    // mode 占 2 位
```

类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。

* 位域在内存中的布局是与机器有关的
* 位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定
* 取地址运算符（&）不能作用于位域，任何指针都无法指向类的位域

### <a id="1.7">struct和typedef struct</a>
#### C 中
```c
// c
typedef struct Student {
    int age; 
} S;
```
等价于
```c
// c
struct Student { 
    int age; 
};
typedef struct Student S;
```
此时 `S` 等价于 `struct Student`，但两个标识符名称空间不相同。
另外还可以定义与 `struct Student` 不冲突的 `void Student() {}`。

#### C++ 中
由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。  
一、如果在类标识符空间定义了 `struct Student {...};`，使用 `Student me;` 时，编译器将搜索全局标识符表，`Student` 未找到，则在类标识符内搜索。`即在c++中可以省略struct关键字`。  
即表现为可以使用 `Student` 也可以使用 `struct Student`，如下：
```cpp
// cpp
struct Student { 
    int age; 
};
void f( Student me );       // 正确，"struct" 关键字可省略
```

二、若定义了与 `Student` 同名函数之后，则 `Student` 只代表函数，不代表结构体，如下：
```cpp
typedef struct Student { 
    int age; 
} S;
void Student() {}           // 正确，定义后 "Student" 只代表此函数
//void S() {}               // 错误，符号 "S" 已经被定义为一个 "struct Student" 的别名
int main() {
    Student(); 
    struct Student me;      // 或者 "S me";
    return 0;
}
```

### <a id="1.8">struct和class和union</a>
总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。
#### struct和class区别
* 最本质的一个区别就是默认的访问控制
  * 默认的继承访问权限。struct 是 public 的，class 是 private 的。  
  * struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。

#### union 联合
联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：
* 默认访问控制符为 public
* 可以含有构造函数、析构函数
* 不能含有引用类型的成员
* 不能继承自其他类，不能作为基类
* 不能含有虚函数
* 匿名 union 在定义所在作用域可直接访问 union 成员
* 匿名 union 不能包含 protected 成员或 private 成员
* 全局匿名联合必须是静态（static）的

### <a id="1.9">using+范围解析运算符</a>
#### using 声明
一条 `using 声明` 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：
```cpp
using namespace_name::name;
```

#### 1.构造函数的 using 声明
在 C++11 中，派生类能够重用其直接基类定义的构造函数。
```cpp
class Derived : Base {
public:
    using Base::Base;
    /* ... */
};
```
如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：
```cpp
Derived(parms) : Base(args) { }
```

#### 2.using 指示
`using 指示` 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：

```cpp
using namespace_name name;
```

#### 3.尽量少使用 `using 指示` 污染命名空间
> 一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它**只导入了指定的名称**。如果该名称与局部名称发生冲突，编译器将**发出指示**。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则**局部名称将覆盖名称空间版本**，而编译器**并不会发出警告**。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。
using 使用
尽量少使用 `using 指示`
```cpp
using namespace std;
```
应该多使用 `using 声明`
```cpp
int x;
std::cin >> x ;
std::cout << x << std::endl;
```
或者
```cpp
using std::cin;
using std::cout;
using std::endl;
int x;
cin >> x;
cout << x << endl;
```

#### :: 范围解析运算符
#### 分类
1. 全局作用域符（`::name`）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间
2. 类作用域符（`class::name`）：用于表示指定类型的作用域范围是具体某个类的
3. 命名空间作用域符（`namespace::name`）:用于表示指定类型的作用域范围是具体某个命名空间的

#### :: 使用
```cpp
int count = 11;         // 全局（::）的 count
class A {
public:
	static int count;   // 类 A 的 count（A::count）
};
int A::count = 21;
void fun()
{
	int count = 31;     // 初始化局部的 count 为 31
	count = 32;         // 设置局部的 count 的值为 32
}
int main() {
	::count = 12;       // 测试 1：设置全局的 count 的值为 12

	A::count = 22;      // 测试 2：设置类 A 的 count 为 22

	fun();		        // 测试 3

	return 0;
}
```

### <a id="1.10">宏</a>
* 宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。

### <a id="1.11">成员初始化列表</a>
#### 作用
* 更高效：少了一次调用默认构造函数的过程。
* 有些场合必须要用初始化列表：
  1. 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
  2. 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
  3. 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化

#### initializer_list 列表初始化
用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 `std::initializer_list` 参数.
initializer_list 使用
```cpp
#include <iostream>
#include <vector>
#include <initializer_list>
 
template <class T>
struct S {
    std::vector<T> v;
    S(std::initializer_list<T> l) : v(l) {
         std::cout << "constructed with a " << l.size() << "-element list\n";
    }
    void append(std::initializer_list<T> l) {
        v.insert(v.end(), l.begin(), l.end());
    }
    std::pair<const T*, std::size_t> c_arr() const {
        return {&v[0], v.size()};  // 在 return 语句中复制列表初始化
                                   // 这不使用 std::initializer_list
    }
};
 
template <typename T>
void templated_fn(T) {}
 
int main()
{
    S<int> s = {1, 2, 3, 4, 5}; // 复制初始化
    s.append({6, 7, 8});      // 函数调用中的列表初始化
 
    std::cout << "The vector size is now " << s.c_arr().second << " ints:\n";
 
    for (auto n : s.v)
        std::cout << n << ' ';
    std::cout << '\n';
 
    std::cout << "Range-for over brace-init-list: \n";
 
    for (int x : {-1, -2, -3}) // auto 的规则令此带范围 for 工作
        std::cout << x << ' ';
    std::cout << '\n';
 
    auto al = {10, 11, 12};   // auto 的特殊规则
 
    std::cout << "The list bound to auto has size() = " << al.size() << '\n';
 
//    templated_fn({1, 2, 3}); // 编译错误！“ {1, 2, 3} ”不是表达式，
                             // 它无类型，故 T 无法推导
    templated_fn<std::initializer_list<int>>({1, 2, 3}); // OK
    templated_fn<std::vector<int>>({1, 2, 3});           // 也 OK
}
```

### <a id="1.12">内存分配和管理</a>
#### malloc、calloc、realloc、alloca
1. malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。
2. calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。
3. realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。
4. alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。

#### malloc、free
用于分配、释放内存
malloc、free 使用
申请内存，确认是否申请成功
```cpp
char *str = (char*) malloc(100);
assert(str != nullptr);
```
释放内存后指针置空
```cpp
free(p); 
p = nullptr;
```

#### new、delete
1. new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。
2. delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。
3. new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。

#### new、delete 使用

申请内存，确认是否申请成功
```cpp
int main()
{
    T* t = new T();     // 先内存分配 ，再构造函数
    delete t;           // 先析构函数，再内存释放
    return 0;
}
```

#### 定位 new
定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。

```cpp
new (place_address) type
new (place_address) type (initializers)
new (place_address) type [size]
new (place_address) type [size] { braced initializer list }
```
* `place_address` 是个指针
* `initializers` 提供一个（可能为空的）以逗号分隔的初始值列表

#### delete this 合法吗？
> [Is it legal (and moral) for a member function to say delete this?](https://isocpp.org/wiki/faq/freestore-mgmt#delete-this)

合法，但：
1. 必须保证 this 对象是通过 `new`（不是 `new[]`、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的
2. 必须保证调用 `delete this` 的成员函数是最后一个调用 this 的成员函数
3. 必须保证成员函数的 `delete this ` 后面没有调用 this 了
4. 必须保证 `delete this` 后没有人使用了

#### 如何定义一个只能在堆上（栈上）生成对象的类？
> [如何定义一个只能在堆上（栈上）生成对象的类?](https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618)

#### 只能在堆上
方法：将析构函数设置为私有

原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。

#### 只能在栈上
方法：将 new 和 delete 重载为私有

原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。

#### 一般应用程序内存空间有如下区域：
- 栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文
- 堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域
- 可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里
- 保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据

栈   
栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：   
- 函数的返回地址和参数
- 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量
- 保存上下文：包括函数调用前后需要保持不变的寄存器
 
堆  
堆分配算法：  
- 空闲链表（Free List）
- 位图（Bitmap）
- 对象池

#### 编译链接过程
- 1.预编译（预编译器处理如 #include、#define 等预编译指令，生成 .i 或 .ii 文件）
- 2.编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 .s 文件）
- 3.汇编（汇编器把汇编码翻译成机器码，生成 .o 文件）
- 4.链接（连接器进行地址和空间分配、符号决议、重定位，生成 .out 文件）

现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld   
MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin   

目标文件存储结构  

| 段                     | 功能                                                                                                                |
| ----------------------- | --------------------------------------------------------------------------------------------------------------------- |
| File Header             | 文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等） |
| .text section           | 代码段，执行语句编译成的机器代码                                                                      |
| .data section           | 数据段，已初始化的全局变量和局部静态变量                                                          |
| .bss section            | BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间） |
| .rodata section         | 只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量 |
| .comment section        | 注释信息段，存放编译器版本信息                                                                         |
| .note.GNU-stack section | 堆栈提示段                                                                                                       |

#### Linux 的共享库
libname.so.x.y.z
- x：主版本号，不同主版本号的库之间不兼容，需要重新编译
- y：次版本号，高版本号向后兼容低版本号
- z：发布版本号，不对接口进行更改，完全兼容

路径  
大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。   
- /lib：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等
- /usr/lib：存放非系统运行时所需要的关键性的库，主要是开发库
- /usr/local/lib：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库

动态链接器会在 /lib、/usr/lib 和由 /etc/ld.so.conf 配置文件指定的，目录中查找共享库

环境变量   
- LD_LIBRARY_PATH：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序
- LD_PRELOAD：指定预先装载的一些共享库甚至是目标文件
- LD_DEBUG：打开动态链接器的调试功能

so 共享库的编写  
```cpp
创建一个名为 MySharedLib 的共享库
CMakeLists.txt
cmake_minimum_required(VERSION 3.10)project(MySharedLib)
set(CMAKE_CXX_STANDARD 11)
add_library(MySharedLib SHARED library.cpp library.h)

library.h
#ifndef MYSHAREDLIB_LIBRARY_H
#define MYSHAREDLIB_LIBRARY_H
// 打印 Hello World!void hello();
// 使用可变模版参数求和template <typename T>
T sum(T t)
{
    return t;
}template <typename T, typename ...Types>
T sum(T first, Types ... rest)
{
    return first + sum<T>(rest...);
}

#endif
library.cpp
#include <iostream>
#include "library.h"
void hello() {
    std::cout << "Hello, World!" << std::endl;
}

so 共享库的使用（被可执行项目调用）
创建一个名为 TestSharedLib 的可执行项目
CMakeLists.txt
cmake_minimum_required(VERSION 3.10)project(TestSharedLib)
# C++11 编译set(CMAKE_CXX_STANDARD 11)
# 头文件路径set(INC_DIR /home/xx/code/clion/MySharedLib)# 库文件路径set(LIB_DIR /home/xx/code/clion/MySharedLib/cmake-build-debug)
include_directories(${INC_DIR})link_directories(${LIB_DIR})link_libraries(MySharedLib)
add_executable(TestSharedLib main.cpp)
# 链接 MySharedLib 库target_link_libraries(TestSharedLib MySharedLib)

main.cpp
#include <iostream>
#include "library.h"using std::cout;using std::endl;
int main() {

    hello();
    cout << "1 + 2 = " << sum(1,2) << endl;
    cout << "1 + 2 + 3 = " << sum(1,2,3) << endl;

    return 0;
}

执行结果
Hello, World!
1 + 2 = 3
1 + 2 + 3 = 6
```


## <a id="2">中级</a>
- [explicit（显式）关键字](#2.1)
- [friend友元类和友元函数](#2.2)
- [decltype](#2.3)
- [左右值引用](#2.4)
- [面对对象编程](#2.5)
- [虚函数](#2.6)
- [智能指针](#2.7)
- [强制类型转换运算符](#2.8)
- [运行时类型信息 (RTTI) ](#2.9)
- [for(auto i : v)](#2.10)
- [shared_from_this)](#2.11)
- [模板](#2.12)
- [boost::lexical_cast](#2.13)
- [find_first_not_of()find_first_of()](#2.14)
- [C++ lambda表达式与函数对象](#2.15)
- [auto](#2.16)
- [C++类的默认函数、赋值、拷贝构造讲解](#2.17)
- [C++11的bind函数](#2.18)

### <a id="2.1">explicit（显式）关键字</a>
参考链接：  
1、C++ explicit关键字详解   
https://blog.csdn.net/guoyunfei123/article/details/89003369     

#### 特征
* explicit 修饰构造函数时，可以防止隐式转换和复制初始化
* explicit 修饰转换函数时，可以防止隐式转换，但 [按语境转换](https://zh.cppreference.com/w/cpp/language/implicit_conversion) 除外

#### 介绍
首先, C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).   

```cpp
class CxString  // 没有使用explicit关键字的类声明, 即默认为隐式声明  
{  
public:  
    char *_pstr;  
    int _size;  
    CxString(int size)  
    {  
        _size = size;                // string的预设大小  
        _pstr = malloc(size + 1);    // 分配string的内存  
        memset(_pstr, 0, size + 1);  
    }  
    CxString(const char *p)  
    {  
        int size = strlen(p);  
        _pstr = malloc(size + 1);    // 分配string的内存  
        strcpy(_pstr, p);            // 复制字符串  
        _size = strlen(_pstr);  
    }  
    // 析构函数这里不讨论, 省略...  
};  
  
// 下面是调用:  

CxString string1(24);     // 这样是OK的, 为CxString预分配24字节的大小的内存  
CxString string2 = 10;    // 这样是OK的, 为CxString预分配10字节的大小的内存  
CxString string3;         // 这样是不行的, 因为没有默认构造函数, 错误为: “CxString”: 没有合适的默认构造函数可用  
CxString string4("aaaa"); // 这样是OK的  
CxString string5 = "bbb"; // 这样也是OK的, 调用的是CxString(const char *p)  
CxString string6 = 'c';   // 这样也是OK的, 其实调用的是CxString(int size), 且size等于'c'的ascii码  
string1 = 2;              // 这样也是OK的, 为CxString预分配2字节的大小的内存  
string2 = 3;              // 这样也是OK的, 为CxString预分配3字节的大小的内存  
string3 = string1;        // 这样也是OK的, 至少编译是没问题的, 但是如果析构函数里用free释放_pstr内存指针的时候可能会报错, 完整的代码必须重载运算符"=", 并在其中处理内存释放  

上面的代码中, "CxString string2 = 10;" 这句为什么是可以的呢? 在C++中, 如果的构造函数只有一个参数时, 那么在编译的时候就会有一个缺省的转换操作:将该构造函数对应数据类型的数据转换为该类对象. 也就是说 "CxString string2 = 10;" 这段代码, 编译器自动将整型转换为CxString类对象, 实际上等同于下面的操作:
CxString string2(10);  
或  
CxString temp(10);  
CxString string2 = temp;

但是, 上面的代码中的_size代表的是字符串内存分配的大小, 那么调用的第二句 "CxString string2 = 10;" 和第六句 "CxString string6 = 'c';" 就显得不伦不类, 而且容易让人疑惑. 有什么办法阻止这种用法呢? 答案就是使用explicit关键字. 我们把上面的代码修改一下, 如下:
class CxString  // 使用关键字explicit的类声明, 显示转换  
{  
public:  
    char *_pstr;  
    int _size;  
    explicit CxString(int size)  
    {  
        _size = size;  
        // 代码同上, 省略...  
    }  
    CxString(const char *p)  
    {  
        // 代码同上, 省略...  
    }  
};  
  
// 下面是调用:  
CxString string1(24);     // 这样是OK的  
CxString string2 = 10;    // 这样是不行的, 因为explicit关键字取消了隐式转换  
CxString string3;         // 这样是不行的, 因为没有默认构造函数  
CxString string4("aaaa"); // 这样是OK的  
CxString string5 = "bbb"; // 这样也是OK的, 调用的是CxString(const char *p)  
CxString string6 = 'c';   // 这样是不行的, 其实调用的是CxString(int size), 且size等于'c'的ascii码, 但explicit关键字取消了隐式转换  
string1 = 2;              // 这样也是不行的, 因为取消了隐式转换  
string2 = 3;              // 这样也是不行的, 因为取消了隐式转换  
string3 = string1;        // 这样也是不行的, 因为取消了隐式转换, 除非类实现操作符"="的重载  

explicit关键字的作用就是防止类构造函数的隐式自动转换.
上面也已经说过了, explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了. 例如: 
class CxString  // explicit关键字在类构造函数参数大于或等于两个时无效  
{  
public:  
    char *_pstr;  
    int _age;  
    int _size;  
    explicit CxString(int age, int size)  
    {  
        _age = age;  
        _size = size;  
        // 代码同上, 省略...  
    }  
    CxString(const char *p)  
    {  
        // 代码同上, 省略...  
    }  
};  
// 这个时候有没有explicit关键字都是一样的  

但是, 也有一个例外, 就是当除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效, 此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数, 例子如下:
class CxString  // 使用关键字explicit声明  
{  
public:  
    int _age;  
    int _size;  
    explicit CxString(int age, int size = 0)  
    {  
        _age = age;  
        _size = size;  
        // 代码同上, 省略...  
    }  
    CxString(const char *p)  
    {  
        // 代码同上, 省略...  
    }  
};  
  
// 下面是调用:  
CxString string1(24);     // 这样是OK的  
CxString string2 = 10;    // 这样是不行的, 因为explicit关键字取消了隐式转换  
CxString string3;         // 这样是不行的, 因为没有默认构造函数  
string1 = 2;              // 这样也是不行的, 因为取消了隐式转换  
string2 = 3;              // 这样也是不行的, 因为取消了隐式转换  
string3 = string1;        // 这样也是不行的, 因为取消了隐式转换, 除非类实现操作符"="的重载  
```

#### explicit 使用
```cpp
struct A
{
	A(int) { }
	operator bool() const { return true; }
};

struct B
{
	explicit B(int) {}
	explicit operator bool() const { return true; }
};

void doA(A a) {}

void doB(B b) {}

int main()
{
	A a1(1);		// OK：直接初始化
	A a2 = 1;		// OK：复制初始化
	A a3{ 1 };		// OK：直接列表初始化
	A a4 = { 1 };		// OK：复制列表初始化
	A a5 = (A)1;		// OK：允许 static_cast 的显式转换 
	doA(1);			// OK：允许从 int 到 A 的隐式转换
	if (a1);		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
	bool a6（a1）;		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
	bool a7 = a1;		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
	bool a8 = static_cast<bool>(a1);  // OK ：static_cast 进行直接初始化

	B b1(1);		// OK：直接初始化
	B b2 = 1;		// 错误：被 explicit 修饰构造函数的对象不可以复制初始化
	B b3{ 1 };		// OK：直接列表初始化
	B b4 = { 1 };		// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化
	B b5 = (B)1;		// OK：允许 static_cast 的显式转换
	doB(1);			// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换
	if (b1);		// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
	bool b6(b1);		// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
	bool b7 = b1;		// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
	bool b8 = static_cast<bool>(b1);  // OK：static_cast 进行直接初始化

	return 0;
}
```

### <a id="2.2">friend友元类和友元函数</a>
* 能访问私有成员  
* 破坏封装性
* 友元关系不可传递
* 友元关系的单向性
* 友元声明的形式及数量不受限制   

如果一个类得函数想要用另外一个类对象的私有成员，需要给类函数指定为友元函数。  

如果一个类用了另一个类得得话，继承后报private不能使用，可以使用public申明在一个类中得类，或者声明使用得类为friend，这样使用得类就能使用。  

### <a id="2.3">decltype</a>
decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：
```cpp
decltype ( expression )
```
#### decltype 使用
```cpp
// 尾置返回允许我们在参数列表之后声明返回类型
template <typename It>
auto fcn(It beg, It end) -> decltype(*beg)
{
    // 处理序列
    return *beg;    // 返回序列中一个元素的引用
}
// 为了使用模板参数成员，必须用 typename
template <typename It>
auto fcn2(It beg, It end) -> typename remove_reference<decltype(*beg)>::type
{
    // 处理序列
    return *beg;    // 返回序列中一个元素的拷贝
}
```

### <a id="2.4">左右值引用</a>
#### 左值和右值的概念
左值是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体；  
右值当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。   
一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。   

#### 引用
引用是C++语法做的优化，引用的本质还是靠指针来实现的。引用相当于变量的别名。引用可以改变指针的指向，还可以改变指针所指向的值。声明引用的时候必须初始化，且一旦绑定，不可把引用绑定到其他对象；即引用必须初始化，不能对引用重定义；
对引用的一切操作，就相当于对原对象的操作。

左值引用，常规引用，一般表示对象的身份。左值引用的基本语法：type &引用名 = 左值表达式；   

右值引用的基本语法type &&引用名 = 右值表达式；右值引用在企业开发人员在代码优化方面会经常用到。右值引用的“&&”中间不可以有空格。

右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。
右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：

* 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
* 能够更简洁明确地定义泛型函数。

左值引用 就是对左值的引用 就是给左值取别名

右值引用 就是对右值的引用 就是给右值取别名

左值	                右值    
在内存中有特定地址的量	在寄存器中的量    

```c++


```

#### 引用折叠

* `X& &`、`X& &&`、`X&& &` 可折叠成 `X&`
* `X&& &&` 可折叠成 `X&&`

### <a id="2.5">面对对象编程</a>
面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。  
<img src="./image/1-1.png" style="zoom:100%"/>

面向对象三大特征 —— 封装、继承、多态

#### 封装
把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。
* `public` 成员：可以被任意实体访问
* `protected` 成员：只允许被子类及本类的成员函数访问
* `private` 成员：只允许被本类的成员函数、友元类或友元函数访问

#### 继承
* 基类（父类）——&gt; 派生类（子类）

#### 多态
* 多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。
* 多态是以封装和继承为基础的。
* C++ 多态分类及实现：
    1. 重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载
    2. 子类型多态（Subtype Polymorphism，运行期）：虚函数
    3. 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板
    4. 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换

> [The Four Polymorphisms in C++](https://catonmat.net/cpp-polymorphism)

#### 静态多态（编译期/早绑定）
函数重载
```cpp
class A
{
public:
    void do(int a);
    void do(int a, int b);
};
```

#### 动态多态（运行期期/晚绑定）
* 虚函数：用 virtual 修饰成员函数，使其成为虚函数  

**注意：**
* 普通函数（非类成员函数）不能是虚函数
* 静态函数（static）不能是虚函数
* 构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）
* 内联函数不能是表现多态性时的虚函数，解释见：[虚函数（virtual）可以是内联函数（inline）吗？](https://github.com/huihut/interview#%E8%99%9A%E5%87%BD%E6%95%B0virtual%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline%E5%90%97)

动态多态使用  
```cpp
class Shape                     // 形状类
{
public:
    virtual double calcArea()
    {
        ...
    }
    virtual ~Shape();
};
class Circle : public Shape     // 圆形类
{
public:
    virtual double calcArea();
    ...
};
class Rect : public Shape       // 矩形类
{
public:
    virtual double calcArea();
    ...
};
int main()
{
    Shape * shape1 = new Circle(4.0);
    Shape * shape2 = new Rect(5.0, 6.0);
    shape1->calcArea();         // 调用圆形类里面的方法
    shape2->calcArea();         // 调用矩形类里面的方法
    delete shape1;
    shape1 = nullptr;
    delete shape2;
    shape2 = nullptr;
    return 0;
}
```

### <a id="2.6">虚函数</a>
#### 虚析构函数
`虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。`
* 虚析构函数使用
```cpp
class Shape
{
public:
    Shape();                    // 构造函数不能是虚函数
    virtual double calcArea();
    virtual ~Shape();           // 虚析构函数
};
class Circle : public Shape     // 圆形类
{
public:
    virtual double calcArea();
    ...
};
int main()
{
    Shape * shape1 = new Circle(4.0);
    shape1->calcArea();    
    delete shape1;  // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。
    shape1 = NULL;
    return 0；
}
```

#### 纯虚函数
纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。  
纯虚类：virtual void Log(LogLevel::Level level, LoggEvent::ptr event) = 0;  
实类必须要实现。实类实现需要在函数后面加override。  
```cpp
virtual int A() = 0;
```

#### 虚函数、纯虚函数
虚函数可以有实现，也可以有空实现。纯虚函数没有实现，属于接口。  
* 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 
* 虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。
* `虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。`
* `带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。`
* 虚基类是虚继承中的基类，具体见下文虚继承。
> [CSDN . C++ 中的虚函数、纯虚函数区别和联系](https://blog.csdn.net/u012260238/article/details/53610462)

#### 虚函数指针、虚函数表
* 虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。
* 虚函数表：在程序只读数据段（`.rodata section`，见：[目标文件存储结构](#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。

> [C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现](https://blog.twofei.com/496/)

#### 虚继承
虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。

底层实现原理与编译器相关，一般通过**虚基类指针**和**虚基类表**实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。

实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。

#### 虚继承、虚函数
* 相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）
* 不同之处：
    * 虚继承
        * 虚基类依旧存在继承类中，只占用存储空间
        * 虚基类表存储的是虚基类相对直接继承类的偏移
    * 虚函数
        * 虚函数不占用存储空间
        * 虚函数表存储的是虚函数地址

#### 模板类、成员模板、虚函数
* 模板类中可以使用虚函数
* 一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数

#### 抽象类、接口类、聚合类
* 抽象类：含有纯虚函数的类
* 接口类：仅含有纯虚函数的抽象类
* 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
    * 所有成员都是 public
    * 没有定义任何构造函数
    * 没有类内初始化
    * 没有基类，也没有 virtual 函数

### <a id="2.7">智能指针</a>
#### C++ 标准库（STL）中
头文件：`#include <memory>`

#### C++ 98
```cpp
std::auto_ptr<std::string> ps (new std::string(str))；
```

#### C++ 11
1. shared_ptr
2. unique_ptr
3. weak_ptr
4. auto_ptr（被 C++11 弃用）
  
参考链接   
https://www.cnblogs.com/findumars/p/11821640.html   

深入智能指针    
https://blog.csdn.net/qiangweiyuan/article/details/88562935    

* Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。
* Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。

##### 1.shared_ptr
多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。

shared_ptr.unique()false不独一，有人在读。  

* 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁

定义对象时，用强智能指针shared_ptr，在其它地方引用对象时，使用弱智能指针weak_ptr。

##### 2.weak_ptr
https://blog.csdn.net/LLZK_/article/details/52431404    


weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。

shared_ptr=weak_ptr.lock()返回shared_ptr

* 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题

weak_ptr 是为了辅助shared_ptr而引入的一种智能指针，它存在的意义就是协助shared_ptr更好的完成工作，我们可以把它比做成一个秘书或助理。

weak_ptr的构造和析构并不会改变引用计数的大小，它可以由一个shared_ptr或weak_ptr的对象构造获得。它没有对“*”和“->”的重载，但可以使用lock获得一个可用的shared_ptr对象。

场景--------------解决shared_ptr的循环引用问题

我们知道，智能指针shared_ptr采用的是引用计数的方式，下面我们来写一个双向链表。

```c++

#include<iostream>
#include<boost/shared_ptr.hpp>
#include<boost/weak_ptr.hpp>
 
using namespace std;
 
struct Node
{
	int _data;
	boost::shared_ptr<Node> _next;
	boost::shared_ptr<Node> _prev;
};
 
int main()
{
	boost::shared_ptr<Node> sp1(new Node);
	boost::shared_ptr<Node> sp2(new Node);
	sp1->_next = sp2;
	sp2->_prev = sp1;
	system("pause");
	return 0;
}
我们暂且将这两块空间称为Node1，和Node2,。我们从上述代码中可知，sp1，sp2，_next，_prev均为shared_ptr类型的智能指针。sp1与sp2->prev都指向Node1，所以sp1的引用计数为2，同理sp1->_next与sp2都指向Node2，所以sp2的引用计数也为2。这是前提，注意，问题来了。

当我们想销毁这个链表或者说销毁一个结点的时候，我们需要将引用计数置为1，假如，我们要delete sp2这块空间，我们需要将sp2的引用计数置为1，就是说我们需要将sp1->_next这个指针销毁掉。把sp2->_next销毁， 就意味着先要把sp1销毁。

如果想把sp1销毁，就要把sp1的引用计数置为1，所以，我们就要把sp2->_prev销毁，要想把sp2->_prev销毁，就代表先要把sp2销毁。

这样一来，我们就陷入了一个无限的循环当中。

这就是所谓的 shared_ptr智能指针的循环引用问题。

我们如何用weak_ptr来解决这个场景呢？

解决：
#include<iostream>
#include<boost/shared_ptr.hpp>
#include<boost/weak_ptr.hpp>
 
using namespace std;
 
struct Node
{
	int _data;
	boost::weak_ptr<Node> _next;
	boost::weak_ptr<Node> _prev;
	//boost::shared_ptr<Node> _next;
	//boost::shared_ptr<Node> _prev;
};
 
int main()
{
	boost::shared_ptr<Node> sp1(new Node);
	boost::shared_ptr<Node> sp2(new Node);
	sp1->_next = sp2;
	sp2->_prev = sp1;
	system("pause");
	return 0;
}
只需要把Node结点里面的指针定义为weak_ptr类型就好，weak_ptr的构造析构不会影响引用计数的大小，当我们采用这种方式时，sp1和sp2的引用计数始终为1，当我们想销毁时就可以随意操作啦！

弱智能指针weak_ptr区别于shared_ptr之处在于：

weak_ptr不会改变资源的引用计数，只是一个观察者的角色，通过观察shared_ptr来判定资源是否存在
weak_ptr持有的引用计数，不是资源的引用计数，而是同一个资源的观察者的计数
weak_ptr没有提供常用的指针操作，无法直接访问资源，需要先通过lock方法提升为shared_ptr强智能指针，才能访问资源
```


##### 3.unique_ptr
unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。

* unique_ptr 用于取代 auto_ptr

unique_ptr 是一个独享所有权的智能指针，它提供了严格意义上的所有权，包括：   
* 1、拥有它指向的对象
* 2、无法进行复制构造，无法进行复制赋值操作。即无法使两个unique_ptr指向同一个对象。但是可以进行移动构造和移动赋值操作
* 3、保存指向某个对象的指针，当它本身被删除释放的时候，会使用给定的删除器释放它指向的对象
unique_ptr 可以实现如下功能：
* 1、为动态申请的内存提供异常安全
* 2、讲动态申请的内存所有权传递给某函数
* 3、从某个函数返回动态申请内存的所有权
* 4、在容器中保存指针
* 5、auto_ptr 应该具有的功能

##### 4.auto_ptr
被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 `std::move` 语义，以及其他瑕疵。

##### 5.scoped_ptr
参考：    
https://blog.csdn.net/yishizuofei/article/details/79136733    

scoped_ptr是一个类似于auto_ptr的智能指针，它包装了new操作符在堆上分配的动态对象，能够保证动态创建的对象在任何时候都可以被正确的删除。但是scoped_ptr的所有权更加严格，不能转让，一旦scoped_pstr获取了对象的管理权，你就无法再从它那里取回来。

正如scoped_ptr(局部指针)名字的含义：这个智能指针只能在作用域里使用，不希望被转让。

```c++
template<class T>
class scoped_ptr{
private:
    T *px;
    scoped_ptr(scoped_ptr const &);
    scoped_ptr & operator=(scoped_ptr const &);
public:
    explicit scoped_ptr(T *p = 0);
    ~scoped_ptr();

    void reset(T *p = 0);

    T & operator*()const;
    T * operator->()const;
    T * get()const;

    operator unspecified-bool-type()const;
    void swap(scoped_ptr & b);
};

可见，scoped_str的构造函数接受一个类型为T*的指针p，创建出一个scoped_ptr对象，并在内部保存指针参数p。p必须是一个new表达式动态分配的结果，或者是一个空指针(0)。当scoped_ptr对象的生命周期结束时，析构函数~scoped_ptr()会使用delete操作自动销毁所保存的指针对象，从而正确的回收资源。

scoped_ptr同时把拷贝构造函数和赋值操作都声明为私有的，禁止对智能指针的复制操作，保证了被它管理的指针不能被转让所有权。

成员函数reset()的功能是重置scoped_ptr；它删除原来报存的指针，再保存新的指针值p。如果p是空指针，那么scoped_ptr将不能持有任何指针。一般情况下reset()不应该被调用，因为它违背了scopd_ptr的本意——资源应该一直由scopd_ptr自己自动管理。

void reset(_Ty * p = 0)  //never throw
{
    this_type(p).swap(*this);
}
实际上拥有权不可转移不够方便，swap()成员函数可以交换两个scopd_ptr保存的原始指针。

template<typename T> void swap(scoped_ptr<T>& a,scoped_ptr<T>& b)
void swap(scoped_ptr & b)
{
    _Ty * tmp = b.px;
    b.px = px;   //tmp临时变量在交换后被释放
    px = tmp;    //保证只被一个智能指针管理
}

函数提供了交换两个scoped pointer的内容的更好的方法。之所以说它更好，是因为swap(scoped1,scoped2) 可以更广泛地用于很多指针类型，包括裸指针和第三方的智能指针。scoped1.swap(scoped2) 则只能用于它的定义所在的智能指针，而不能用于裸指针。

scoped_ptr用operator*()和operator->()重载了引用操作符*和箭头操作符->，以模仿被代理的原始指针的行为，因此可以把scopd_ptr对象如同指针一样的使用。如果scopd_ptr保存空指针，那么这两个操作都是未定义的。

scopd_ptr不支持比较操作，不能在两个scopd_ptr之间，scopd_ptr和原始指针之间或空指针之间进行相等或者不等的操作，我们也无法为它编写额外的比较函数，因为它已经将operator== 和 operator!=两个操作符声明为私有的。

1.成员函数讲解
explicit scoped_ptr(T* p=0)
构造函数，存储p的一份拷贝。注意，p 必须是用operator new分配的，或者是null. 在构造的时候，不要求T必须是一个完整的类型。当指针p是调用某个分配函数的结果而不是直接调用new得到的时候很有用：因为这个类型不必是完整的，只需要类型T的一个前向声明就可以了。这个构造函数不会抛出异常。

~scoped_ptr()
删除指针所指向的对象。类型T在被销毁时必须是一个完整的类型。如果scoped_ptr在它被析构时并没有保存资源，它就什么都不做。这个析构函数不会抛出异常。

void reset(T* p=0);
重置一个 scoped_ptr 就是删除它已保存的指针，如果它有的话，并重新保存p. 通常，资源的生存期管理应该完全由scoped_ptr自己处理，但是在极少数时候，资源需要在scoped_ptr的析构之前释放，或者scoped_ptr要处理它原有资源之外的另外一个资源。这时，就可以用reset，但一定要尽量少用它。(过多地使用它通常表示有设计方面的问题) 这个函数不会抛出异常。

T& operator*() const;
该运算符返回一个智能指针中存储的指针所指向的对象的引用。由于不允许空的引用，所以解引用一个拥有空指针的scoped_ptr将导致未定义行为。如果不能肯定所含指针是否有效，就用函数get替代解引用。这个函数不会抛出异常。

T* operator->() const;
返回智能指针所保存的指针。如果保存的指针为空，则调用这个函数会导致未定义行为。如果不能肯定指针是否空的，最好使用函数get。这个函数不会抛出异常。

T* get() const;
返回保存的指针。应该小心地使用get，因为它可以直接操作裸指针。但是，get使得你可以测试保存的指针是否为空。这个函数不会抛出异常。get通常在调用那些需要裸指针的函数时使用。

operator unspecified_bool_type() const
返回scoped_ptr是否为非空。返回值的类型是未指明的，但这个类型可被用于Boolean的上下文（boolean context）中。在if语句中最好使用这个类型转换函数，而不要用get去测试scoped_ptr的有效性。

void swap(scoped_ptr& b)
交换两个scoped_ptr的内容。这个函数不会抛出异常。

2.用法
scoped_ptr的用法与普通的指针几乎没什么区别；最大的差别在于你不必再记得在指针上调用delete，还有复制是不允许的。典型的指针操作(operator* 和 operator->)都被重载了，并提供了和裸指针一样的语法。用scoped_ptr和用裸指针一样快，也没有大小上的增加，因此它们可以广泛使用。使用boost::scoped_ptr时，包含头文件”boost/scoped_ptr.hpp”. 在声明一个scoped_ptr时，用被指物的类型来指定类模板的参数。例如，以下是一个包含std::string指针的scoped_ptr：
boost::scoped_ptr p(new std::string(“Hello”));
当scoped_ptr被销毁时，它对它所拥有的指针调用delete 。

3.与auto_ptr的区别
scoped_ptr的用法和auto_ptr几乎一样，大多数情况下它都可以与auto_ptr互相替换，它也可以从一个auto_ptr获得指针的管理权(同时auto_ptr失去管理权)。

scoped_ptr和auto_ptr一样不能用作容器的元素，但原因不同:auto_ptr是因为它的转移语义，而scoped_ptr则是因为不支持拷贝和赋值，不符合容器对元素类型的要求。

scoped_ptr和auto_ptr的根本区别在于所有权。auto_ptr特意被设计为指针的所有权是可以被转移的，可以在函数之间传递，同一时刻只能有一个auto_ptr管理指针。而scoped_ptr把拷贝构造函数和赋值函数都声明为私有的，拒绝了指针所有权的转让，只有scoped_ptr自己能够管理指针，其他任何人都无权访问被管理的指针，从而保证了指针的绝对安全。
如下代码所示：

auto_ptr<int> ap(new int(10)); //一个int自动指针
scoped_ptr<int>sp (ap);        //从auto_ptr获得原始指针
assert(ap.get() == 0);         //原auto_ptr不再拥有指针

ap.rest(new int(20));          //auto_ptr拥有新的指针
cout <<*ap<<","<<*sp<<endl;    

auto_ptr<int>ap2;
ap2 = ap;                      //ap2从ap获得原始指针，所有权转移
assert(ap.get() == 0);         //ap不再拥有原始指针
scoped_ptr<int>sp2;            //另一个scoped_ptr
sp2 = sp;                      //赋值操作，无法同过编译！

如果代码企图从一个scoped_ptr构造或赋值另一个scoped_ptr(最后一行)，那么编译器会报错，阻止这么做，保护了你的代码。
比起auto_ptr，scoped_ptr更明确地表明了代码原始编写者的意图；只能在定义的作用域内使用，不可转让，这在代码后续的维护生命周期中很重要。
```


##### 6.auto_ptr 与 unique_ptr 比较
* auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了`move` 语义；
* auto_ptr 对象不能管理数组（析构调用 `delete`），unique_ptr 可以管理数组（析构调用 `delete[]` ）；

##### 7.智能指针用法
智能指针可以像类的原始指针一样访问类的public成员，`成员函数get()返回一个原始的指针，成员函数reset()重新绑定指向的对象，而原来的对象则会被释放。release，这个函数只是把智能指针赋值为空，但是它原来指向的内存并没有被释放，相当于它只是释放了对资源的所有权。`
```cpp
auto_ptr<Test> ptest(new Test("123"));
ptest->setStr("hello ");
ptest->print();
ptest.get()->print();
ptest->getStr() += "world !";
(*ptest).print();
ptest.reset(new Test("123"));
ptest->print();
```
注意我们访问auto_ptr的成员函数时用的是“.”，访问指向对象的成员时用的是“->”。    

当我们对智能指针进行赋值时，如ptest2 = ptest，ptest2会接管ptest原来的内存管理权，ptest会变为空指针，如果ptest2原来不为空，则它会释放原来的资源，基于这个原因，应该避免把auto_ptr放到容器中，因为算法对容器操作时，很难避免STL内部对容器实现了赋值传递操作，这样会使容器中很多元素被置为NULL。判断一个智能指针是否为空不能使用if(ptest == NULL)，应该使用if(ptest.get() == NULL).  

`ptest2 = std::move(ptest);//不能直接ptest2 = ptest`   
unique_ptr 和 auto_ptr用法很相似，不过不能使用两个智能指针赋值操作，应该使用std::move; 而且它可以直接用if(ptest == NULL)来判断是否空指针；release、get、reset等用法也和auto_ptr一致，使用函数的返回值赋值时，可以直接使用=, 这里使用c++11 的移动语义特性。另外注意的是当把它当做参数传递给函数时（使用值传递，应用传递时不用这样），传实参时也要使用std::move,比如foo(std::move(ptest))。它还增加了一个成员函数swap用于交换两个智能指针的值。  

share_ptr (官方文档)  
从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。出了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。  
```cpp
int main()
{
    shared_ptr<Test> ptest(new Test("123"));
    shared_ptr<Test> ptest2(new Test("456"));
    cout<<ptest2->getStr()<<endl;
    cout<<ptest2.use_count()<<endl;
    ptest = ptest2;//"456"引用次数加1，“123”销毁
    ptest->print();
    cout<<ptest2.use_count()<<endl;//2
    cout<<ptest.use_count()<<endl;//2
    ptest.reset();
    ptest2.reset();//此时“456”销毁
    cout<<"done !\n";
    return 0;
}
```

weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。   

unique_ptr ：独享所有权，auto得升级。move不能=赋值。  
auto_ptr ：已经废除  
shared_ptr ：可以被多个指针共享。  
weak_ptr ：解决shared_ptr相互引用时的死锁问题。用lock函数来获得shared_ptr。  

总结   
1. shared_ptr采用引用计数的方式管理所指向的对象。
2. shared_ptr可以使用一个new表达式返回的指针进行初始化；但是，不能将一个new表达式返回的指针赋值给shared_ptr。
3. 一旦将一个new表达式返回的指针交由shared_ptr管理之后，就不要再通过普通指针访问这块内存。
4. shared_ptr可以通过reset方法重置指向另一个对象，此时原对象的引用计数减一。
5. 可以定制一个deleter函数，用于在shared_ptr释放对象时调用。
6. unique_ptr对于所指向的对象，是独占的。
7. 不可以对unique_ptr进行拷贝、赋值等操作，但是可以通过release函数在unique_ptr之间转移控制权。
8. unique_ptr可以作为函数的返回值和参数使用。
9. unique_ptr同样可以设置deleter，需要在模板参数中指定deleter的类型。
10. weak_ptr一般和shared_ptr配合使用。它可以指向shared_ptr所指向的对象，但是却不增加对象的引用计数。
11. weak_ptr有一个lock函数，尝试取回一个指向对象的shared_ptr。


### <a id="2.8">强制类型转换运算符</a>
> [MSDN . 强制转换运算符](https://msdn.microsoft.com/zh-CN/library/5f6c9f8h.aspx)

#### static_cast
* 用于非多态类型的转换
* 不执行运行时类型检查（转换安全性不如 dynamic_cast）
* 通常用于转换数值数据类型（如 float -> int）
* 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）

> 向上转换是一种隐式转换。

#### dynamic_cast
* 用于多态类型的转换
* 执行行运行时类型检查
* 只适用于指针或引用
* 对不明确的指针的转换将失败（返回 nullptr），但不引发异常
* 可以在整个类层次结构中移动指针，包括向上转换、向下转换

#### const_cast 
* 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）

#### reinterpret_cast
* 用于位的简单重新解释
* 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。
* 允许将任何指针转换为任何其他指针类型（如 `char*` 到 `int*` 或 `One_class*` 到 `Unrelated_class*` 之类的转换，但其本身并不安全）
* 也允许将任何整数类型转换为任何指针类型以及反向转换。
* reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 
* reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。

#### bad_cast
* 由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。

bad_cast 使用
```cpp
try {  
    Circle& ref_circle = dynamic_cast<Circle&>(ref_shape);   
}  
catch (bad_cast b) {  
    cout << "Caught: " << b.what();  
} 
```

### <a id="2.9">运行时类型信息 (RTTI) </a>
#### dynamic_cast
* 用于多态类型的转换

#### typeid
* typeid 运算符允许在运行时确定对象的类型
* type\_id 返回一个 type\_info 对象的引用
* 如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数
* 只能获取对象的实际类型

#### type_info
* type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。
* 头文件：`typeinfo`

#### typeid、type_info 使用
```cpp
#include <iostream>
using namespace std;

class Flyable                       // 能飞的
{
public:
    virtual void takeoff() = 0;     // 起飞
    virtual void land() = 0;        // 降落
};
class Bird : public Flyable         // 鸟
{
public:
    void foraging() {...}           // 觅食
    virtual void takeoff() {...}
    virtual void land() {...}
    virtual ~Bird(){}
};
class Plane : public Flyable        // 飞机
{
public:
    void carry() {...}              // 运输
    virtual void takeoff() {...}
    virtual void land() {...}
};

class type_info
{
public:
    const char* name() const;
    bool operator == (const type_info & rhs) const;
    bool operator != (const type_info & rhs) const;
    int before(const type_info & rhs) const;
    virtual ~type_info();
private:
    ...
};

void doSomething(Flyable *obj)                 // 做些事情
{
    obj->takeoff();

    cout << typeid(*obj).name() << endl;        // 输出传入对象类型（"class Bird" or "class Plane"）

    if(typeid(*obj) == typeid(Bird))            // 判断对象类型
    {
        Bird *bird = dynamic_cast<Bird *>(obj); // 对象转化
        bird->foraging();
    }

    obj->land();
}

int main(){
	Bird *b = new Bird();
	doSomething(b);
	delete b;
	b = nullptr;
	return 0;
}
```

### <a id="2.10">for(auto i : v)</a>
相当于for each。v是一个可遍历的容器或流，比如vector类型，i就用来在遍历过程中获得容器里的每一个元素。  
```cpp
vector<int> v={1,2,3,4};
for(auto i:v)
cout<<i;
结果就是1234
```

### <a id="2.11">shared_from_this</a>
https://www.cnblogs.com/wangshaowei/p/10669646.html  

c++11中的shared_from_this()来源于boost中的enable_shared_form_this类和shared_from_this()函数，功能为返回一个当前类的std::share_ptr。  

在什么情况下要使类A继承enable_share_from_this？  
#### 使用场合  
当类A被share_ptr管理，且在类A的成员函数里需要把当前类对象作为参数传给其他函数时，就需要传递一个指向自身的share_ptr。  

我们就使类A继承enable_share_from_this，然后通过其成员函数share_from_this()返回当指向自身的share_ptr。  
以上有2个疑惑：   

1.把当前类对象作为参数传给其他函数时，为什么要传递share_ptr呢？直接传递this指针不可以吗？  
　　一个裸指针传递给调用者，谁也不知道调用者会干什么？假如调用者delete了该对象，而share_tr此时还指向该对象。  
2.这样传递share_ptr可以吗？share_ptr  
这样会造成2个非共享的share_ptr指向一个对象，最后造成2次析构该对象。 

#### 补充
enable_shared_from_this是一个模板类，定义于头文件<memory>，其原型为：   
```c++
template< class T > class enable_shared_from_this;

std::enable_shared_from_this 能让一个对象（假设其名为 t ，且已被一个 std::shared_ptr 对象 pt 管理）安全地生成其他额外的 std::shared_ptr 实例（假设名为 pt1, pt2, ... ） ，它们与 pt 共享对象 t 的所有权。
若一个类 T 继承 std::enable_shared_from_this<T> ，则会为该类 T 提供成员函数： shared_from_this 。 当 T 类型对象 t 被一个为名为 pt 的 std::shared_ptr<T> 类对象管理时，调用 T::shared_from_this 成员函数，将会返回一个新的 std::shared_ptr<T> 对象，它与 pt 共享 t 的所有权。

一.使用场合
当类A被share_ptr管理，且在类A的成员函数里需要把当前类对象作为参数传给其他函数时，就需要传递一个指向自身的share_ptr。

1.为何不直接传递this指针
使用智能指针的初衷就是为了方便资源管理，如果在某些地方使用智能指针，某些地方使用原始指针，很容易破坏智能指针的语义，从而产生各种错误。

2.可以直接传递share_ptr<this>么？
答案是不能，因为这样会造成2个非共享的share_ptr指向同一个对象，未增加引用计数导对象被析构两次。例如：

#include <memory>
#include <iostream>

class Bad
{
public:
std::shared_ptr<Bad> getptr() {
    return std::shared_ptr<Bad>(this);
}
~Bad() { std::cout << "Bad::~Bad() called" << std::endl; }
};

int main()
{
    // 错误的示例，每个shared_ptr都认为自己是对象仅有的所有者
    std::shared_ptr<Bad> bp1(new Bad());
    std::shared_ptr<Bad> bp2 = bp1->getptr();
    // 打印bp1和bp2的引用计数
    std::cout << "bp1.use_count() = " << bp1.use_count() << std::endl;
    std::cout << "bp2.use_count() = " << bp2.use_count() << std::endl;
} // Bad 对象将会被删除两次
输出结果如下：

当然，一个对象被删除两次会导致崩溃。

正确的实现如下：

#include <memory>
#include <iostream>

struct Good : std::enable_shared_from_this<Good> // 注意：继承
{
public:
std::shared_ptr<Good> getptr() {
    return shared_from_this();
}
~Good() { std::cout << "Good::~Good() called" << std::endl; }
};

int main()
{
// 大括号用于限制作用域，这样智能指针就能在system("pause")之前析构
{
    std::shared_ptr<Good> gp1(new Good());
    std::shared_ptr<Good> gp2 = gp1->getptr();
    // 打印gp1和gp2的引用计数
    std::cout << "gp1.use_count() = " << gp1.use_count() << std::endl;
    std::cout << "gp2.use_count() = " << gp2.use_count() << std::endl;
}
system("pause");
}

二.为何会出现这种使用场合
因为在异步调用中，存在一个保活机制，异步函数执行的时间点我们是无法确定的，然而异步函数可能会使用到异步调用之前就存在的变量。为了保证该变量在异步函数执期间一直有效，我们可以传递一个指向自身的share_ptr给异步函数，这样在异步函数执行期间share_ptr所管理的对象就不会析构，所使用的变量也会一直有效了（保活）。

因此，如果代码比较复杂，我们在使用shared_ptr的时候其实很难知道是否会有循环引用，所以即使有weak_ptr来解决这个问题，我们也不太容易知道何时能用到，除非清楚非常清楚类之间的关系，所以，在我们编程的时候尽量使用一个指针控制生命周期（即使用shared_ptr），而多个指针控制访问（即使用weak_ptr）。如果这个对象对外指针有多个类控制其生命周期需要用weak，如果只是自己控制就用shared。如果必须要通过函数交给其他函数进行控制可以用 shared_from_this()，当类A被share_ptr管理，且在类A的成员函数里需要把当前类对象作为参数传给其他函数时，就需要传递一个指向自身的share_ptr
```

### <a id="2.12">模板</a>
#### 模板函数  
```cpp
template<typename T>
 void Swap(T *a, T *b){
    T temp = *a;
    *a = *b;
    *b = temp;
}
```

typename关键字也可以使用class关键字替代，它们没有任何区别。C++ 早期对模板的支持并不严谨，没有引入新的关键字，而是用 class 来指明类型参数，但是 class 关键字本来已经用在类的定义中了，这样做显得不太友好，所以后来 C++ 又引入了一个新的关键字 typename，专门用来定义类型参数。不过至今仍然有很多代码在使用 class 关键字，包括 C++ 标准库、一些开源程序等。  

#### 模板类
```cpp
template<typename T1, typename T2>  //这里不能有分号
class Point{
public:
    Point(T1 x, T2 y): m_x(x), m_y(y){ }
public:
    T1 getX() const;  //获取x坐标
    void setX(T1 x);  //设置x坐标
    T2 getY() const;  //获取y坐标
    void setY(T2 y);  //设置y坐标
private:
    T1 m_x;  //x坐标
    T2 m_y;  //y坐标
};
上面的代码仅仅是类的声明，我们还需要在类外定义成员函数。在类外定义成员函数时仍然需要带上模板头，格式为：
template<typename 类型参数1 , typename 类型参数2 , …>
返回值类型 类名<类型参数1 , 类型参数2, ...>::函数名(形参列表){
    //TODO:
}
template<typename 类型参数1 , typename 类型参数2 , …> class 类名{
    //TODO:
};
关于类模板的使用:类模板的使用实际上是将类模板实例化成一个具体的类，它的格式为：类名<实际的类型>
```

对于用于模板定义的依赖于模板参数的名称，只有在实例化的参数中存在这个类型名，或者这个名称前使用了typename关键字来修饰，编译器才会将该名称当成是类型。除了以上这两种情况，绝不会被当成是类型。  

T::iterator实际上可以是以下三种中的任何一种类型：  
静态数据成员  
静态成员函数  
嵌套类型   
因此，如果你想直接告诉编译器T::iterator是类型而不是变量，只需用typename修饰。
template <class T>
void foo() {
    typename T::iterator * iter;
    // ...
}
这样编译器就可以确定T::iterator是一个类型，而不再需要等到实例化时期才能确定，因此消除了前面提到的歧义。  

typename在下面情况下禁止使用：   
模板定义之外，即typename只能用于模板的定义中  
非限定类型，比如前面介绍过的int，vector<int>之类  
基类列表中，比如template <class T> class C1 : T::InnerType不能在T::InnerType前面加typename  
构造函数的初始化列表中  

### <a id="2.13">boost::lexical_cast</a>
boost::lexical_cast为数值之间的转换（conversion）提供了一揽子方案，比如：将一个字符串"123"转换成整数123。  
string s = "123";    
int a = lexical_cast<int>(s);   

### <a id="2.14">find_first_not_of() find_first_of()</a>
这两个方法都是查找与（）中指定的字符串中任意一个字符都不相符的字符的位置地址，而不是返回的是与（）中制定的字符串完全匹配的字符串的首地址。  

### <a id="2.15">C++ lambda表达式与函数对象</a>
```cpp
我们先从简答的例子开始，我们定义一个可以输出字符串的lambda表达式，表达式一般都是从方括号[]开始，然后结束于花括号{}，花括号里面就像定义函数那样，包含了lamdba表达式体：

// 定义简单的lambda表达式auto basicLambda = [] { cout << "Hello, world!" << endl; };// 调用
basicLambda();   // 输出：Hello, world!
// 指明返回类型auto add = [](int a, int b) -> int { return a + b; };// 自动推断返回类型auto multiply = [](int a, int b) { return a * b; };
int sum = add(2, 5);   // 输出：7int product = multiply(2, 5);  // 输出：10

int main(){
    int x = 10;
    auto add_x = [x](int a) mutable { x *= 2; return a + x; };  // 复制捕捉x
    cout << add_x(10) << endl; // 输出 30
    return 0;
}
```

闲话少说，归入正题，捕获的方式可以是引用也可以是复制，但是具体说来会有以下几种情况来捕获其所在作用域中的变量：
- []：默认不捕获任何变量；
- [=]：默认以值捕获所有变量；
- [&]：默认以引用捕获所有变量；
- [x]：仅以值捕获x，其它变量不捕获；
- [&x]：仅以引用捕获x，其它变量不捕获；
- [=, &x]：默认以值捕获所有变量，但是x是例外，通过引用捕获；
- [&, x]：默认以引用捕获所有变量，但是x是例外，通过值捕获；
- [this]：通过引用捕获当前对象（其实是复制指针）；
- [*this]：通过传值方式捕获当前对象；

### <a id="2.16">auto</a>
参考连接：   
1.C++11特性：auto关键字   
https://www.cnblogs.com/QG-whz/p/4951177.html    

```cpp
1.用于代替冗长复杂、变量使用范围专一的变量声明。
想象一下在没有auto的时候，我们操作标准库时经常需要这样：
#include<string>
#include<vector>
int main()
{
    std::vector<std::string> vs;
    for (std::vector<std::string>::iterator i = vs.begin(); i != vs.end(); i++)
    {
        //...
    }
}

#include<string>
#include<vector>
int main()
{
    std::vector<std::string> vs;
    for (auto i = vs.begin(); i != vs.end(); i++)
    {
        //..
    }
}
for循环中的i将在编译时自动推导其类型，而不用我们显式去定义那长长的一串。

2.在定义模板函数时，用于声明依赖模板参数的变量类型。
template <typename _Tx,typename _Ty>
void Multiply(_Tx x, _Ty y)
{
    auto v = x*y;
    std::cout << v;
}
若不使用auto变量来声明v，那这个函数就难定义啦，不到编译的时候，谁知道x*y的真正类型是什么呢？

3.模板函数依赖于模板参数的返回值
template <typename _Tx, typename _Ty>
auto multiply(_Tx x, _Ty y)->decltype(_Tx*_Ty)
{
    return x*y;
}
当模板函数的返回值依赖于模板的参数时，我们依旧无法在编译代码前确定模板参数的类型，故也无从知道返回值的类型，这时我们可以使用auto。格式如上所示。

decltype操作符用于查询表达式的数据类型，也是C++11标准引入的新的运算符，其目的也是解决泛型编程中有些类型由模板参数决定，而难以表示它的问题。
auto在这里的作用也称为返回值占位，它只是为函数返回值占了一个位置，真正的返回值是后面的decltype(_Tx*_Ty)。为何要将返回值后置呢？如果没有后置，则函数声明时为：

decltype(_Tx*_Ty)multiply(_Tx x, _Ty y)
而此时_Tx,_Ty还没声明呢，编译无法通过。
```

注意事项：    
```c++
1.auto 变量必须在定义时初始化，这类似于const关键字。定义在一个auto序列的变量必须始终推导成同一类型。例如：
    auto a4 = 10, a5 = 20, a6 = 30;//正确
    auto b4 = 10, b5 = 20.0, b6 = 'a';//错误,没有推导为同一类型
使用auto关键字做类型自动推导时，依次施加一下规则：

2.如果初始化表达式是引用，则去除引用语义。
    int a = 10;
    int &b = a;
    auto c = b;//c的类型为int而非int&（去除引用）
    auto &d = b;//此时c的类型才为int&
    c = 100;//a =10;    //不引用，不改变原有值
    d = 100;//a =100;  //引用，改变原有值

3.如果初始化表达式为const或volatile（或者两者兼有），则除去const/volatile语义。
    const int a1 = 10;
    auto  b1= a1; //b1的类型为int而非const int（去除const）
    const auto c1 = a1;//此时c1的类型为const int
    b1 = 100;//合法
    c1 = 100;//非法

4.如果auto关键字带上&号，则不去除const语意。
    const int a2 = 10;
    auto &b2 = a2;//因为auto带上&，故不去除const，b2类型为const int
    b2 = 10; //非法
这是因为如何去掉了const，则b2为a2的非const引用，通过b2可以改变a2的值，则显然是不合理的。

5.初始化表达式为数组时，auto关键字推导类型为指针。
    int a3[3] = { 1, 2, 3 };
    auto b3 = a3;
    cout << typeid(b3).name() << endl;
程序将输出
int *

6.若表达式为数组且auto带上&，则推导类型为数组类型。
    int a7[3] = { 1, 2, 3 };
    auto & b7 = a7;
    cout << typeid(b7).name() << endl;
程序输出
int [3]

7.函数或者模板参数不能被声明为auto
void func(auto a)  //错误
{
    //... 
}

8.时刻要注意auto并不是一个真正的类型。
auto仅仅是一个占位符，它并不是一个真正的类型，不能使用一些以类型为操作数的操作符，如sizeof或者typeid。
    cout << sizeof(auto) << endl;//错误
    cout << typeid(auto).name() << endl;//错误
```
auto可以当作一个占位符。

### <a id="2.17">C++类的默认函数、赋值、拷贝构造讲解</a>
参考链接：   
1.C++类的默认函数     
https://www.cnblogs.com/yuwanxian/p/10924835.html   
  
2.赋值运算符和拷贝构造函数的区别与联系    
https://blog.csdn.net/hebbely/article/details/65437510    


#### 1.默认函数
```c++
在C++中，一个类有八个默认函数：
默认构造函数；
默认拷贝构造函数；
默认析构函数；
默认重载赋值运算符函数；
默认重载取址运算符函数；
默认重载取址运算符const函数；
默认移动构造函数（C++11）；
默认重载移动赋值操作符函数（C++11）。

class A
{
public:
    A(); // 默认构造函数;
    
    A(const A&);// 默认拷贝构造函数

    ~A();    // 默认析构函数

    A& operator = (const A&);    // 默认重载赋值运算符函数

    A* operator & ();    // 默认重载取址运算符函数

    const A* operator & () const;    // 默认重载取址运算符const函数

    A(A&&);    // 默认移动构造函数

    A& operator = (const A&&);    // 默认重载移动赋值操作符

};

C++编译器还会为以下这些自定义类型提供全局默认操作符函数
operator ,
operator &
operator &&
operator *
operator ->
operator ->*
operator new
operator delete

只是声明一个空类，不做任何事情的话，编译器会自动为你生成一个默认构造函数、一个默认拷贝构造函数、一个默认重载赋值操作符函数和一个默认析构函数。这些函数只有在第一次被调用时，才会被编译器创建，当然这几个生成的默认函数的实现就是什么都不做。所有这些函数都是inline和public的。

我们不希望对象被显示构造（单列模式）或赋值，可以将对应函数声明为private，或者写一个基类，开放部分默认函数，子类去继承就可以了。C++11新增标识符default和delete,控制这些默认函数是否使用。

default：被标识的默认函数将使用类的默认行为，如：A() = default;default函数仅适用于类的特殊成员函数，且该特殊成员函数没有默认参数。default函数既可以在类内声明类外定义，也可以在类内直接定义。

delete：被标识的默认函数将禁用，如：A() = delete;

override：被标识的函数需要强制重写基类虚函数；

final：被标识的函数禁止重写基类虚函数；
```

#### 2.构造函数（Constructor）
1.构造函数作用是对对象进行初始化，在堆上new一个对象或在栈上定义一个临时对象时，会自动调用对象的构造函数。有初始化列表和构造函数体内赋值两种方式，初始化列表在初始化对象时更高效（每个成员在初始化列表中只能出现一次），减少了一次赋值操作，推荐此方法；以下成员变量必须在初始化列表中初始化：常量成员变量、引用类型成员变量、没有缺省构造函数的成员变量（如果构造函数的参数列表中有一个类的对象，并且该对象的类里没有缺省参数的构造函数时，要是不使用初始化列表，参数中会调用无参或者全缺省的构造函数，而那个类中又没有）；

2.函数名与类名相同，可以重载，不能为虚函数，不能有返回值，连void也不行；

3.如果没有显式定义，编译器会自动生成一个默认的构造函数，默认的构造函什么都不会做；

4.无参构造函数和带有缺省值的构造函数（全缺省）都认为是缺省的构造函数，并且缺省的构造函数只能有一个；

5.函数体内可以使用this指针，但不可以用于初始化列表。因为构造函数只是初始化对象，初始化之前此对象已经存在了，所以可以有this，函数体里面是进行赋值，初始化列表是对类中的各个成员变量进行初始化，初始化的位置对象不完整，所以不能使用this用于初始化列表；

6.对于出现单参数的构造函数需要注意，C++会默认将参数对应的类型转换为该类类型，有时候这种隐式的转换是我们不想要的，需要使用explicit关键字来限制这种转换；

7.构造顺序：虚拟基类的构造函数（如果有多个虚拟基类，按照它们被继承的顺序构造，而不是它们在成员初始化列表中的顺序）；   
非虚拟基类的构造函函（如果有多个非虚拟基类，按照它们被继承的顺序构造，而不是它们在成员初始化列表中的顺序）；  
成员对象的构造函数（如果有多个成员类对象，按照它们声明的顺序调用，而不是它们在成员初始化列表中的顺序）；   
本类构造函数。构造的过程是递归的。  


#### 3.拷贝构造函数（Copy Constructor）
1.拷贝构造函数实际上是构造函数的重载，具有一般构造函数的所有特性，用此类已有的对象创建一个新的对象，一般在函数中会将已存在对象的数据成员的值复制一份到新创建的对象中。用类的一个已知的对象去初始化该类的另一个对象时，会自动调用对象的拷贝构造函数；

2.函数名与类名相同，第一个参数是对某个同类对象的引用，且没有其他参数或其他参数都有默认值，返回值是类对象的引用，通过返回引用值可以实现连续构造，即类似A(B(C))这样；

3.如果没有显式定义，编译器会自动生成一个默认的拷贝构造函数，默认的拷贝构造函数会依次拷贝类的数据成员完成初始化；

4.浅拷贝和深拷贝：编译器创建的默认拷贝构造函数只会执行"浅拷贝"，也就是通过赋值完成，如果该类的数据成员中有指针成员，也只是地址的拷贝，会使得新的对象与拷贝对象该指针成员指向的地址相同，delete该指针时则会导致两次重复delete而出错，如果指针成员是new出来就是“深拷贝”。

#### 4.析构函数（Destructor）
1.析构函数作用是做一些清理工作，delete一个对象或对象生命周期结束时，会自动调用对象的析构函数；

2.函数名在类名前加上字符~，没有参数（可以有void类型的参数），也没有返回值，可以为虚函数（通过基类的指针去析构子类对象时候），不能重载，故析构函数只有一个；

3.如果没有显式定义，编译器会自动生成一个默认的析构函数，默认的析构函什么都不会做；

4.析构顺序：和构造函数顺序相反。析构的过程也是递归的。

#### 5.重载赋值运算符函数（Copy Assignment operator）
1.它是两个已有对象，一个给另一个赋值的过程。当两个对象之间进行赋值时，会自动调用重载赋值运算符函数，它不同于拷贝构造函数，拷贝构造函数是用已有对象给新生成的对象赋初值的过程；

2.赋值运算符重载函数参数中const和&没有强制要求，返回值是类对象的引用，通过返回引用值可以实现连续赋值，即类似a=b=c这样，返回值类型也不是强制的，可以返回void，使用时就不能连续赋值；

3.赋值运算符重载函只能定义为类的成员函数，不能是静态成员函数，也不能是友元函数，赋值运算符重载函数不能被继承，要避免自赋值；

4.如果没有显式定义，编译器会自动生成一个默认的赋值运算符重载函数，默认的赋值运算符重载函数实现将数据成员逐一赋值的一种浅拷贝，会导致指针悬挂问题。

#### 6.重载取址运算符（const）函数
1.重载取址运算符函数没有参数；

2.如果没有显式定义，编译器会自动生成默认的重载取址运算符函数，函数内部直接return this，一般使用默认即可。

#### 7.移动构造函数和重载移动赋值操作符函数
1.C++11 新增move语义：源对象资源的控制权全部交给目标对象，可以将原对象移动到新对象， 用于a初始化b后，就将a析构的情况；

2.移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用；

3.临时对象即将消亡，并且它里面的资源是需要被再利用的，这个时候就可以使用移动构造。移动构造可以减少不必要的复制，带来性能上的提升。

#### 8.赋值运算符和拷贝构造函数的区别与联系
```c++
C++中一般创建对象，拷贝或赋值的方式有构造函数，拷贝构造函数，赋值函数这三种方法。拷贝构造函数使用已有的对象创建一个新的对象，赋值运算符是将一个对象的值复制给另一个已存在的对象。区分是调用拷贝构造函数还是赋值运算符，主要是否有新的对象产生。

A (A& a);						//拷贝构造函数  
A (const A& a);					//拷贝构造函数   
A& operator= (const A& a);		//赋值构造函数   

① 拷贝构造函数是C++独有的，它是一种特殊的构造函数，用基于同一类的一个对象构造和初始化另一个对象。   
② 在默认情况下（用户没有定义，但是也没有显式的删除），编译器会自动的隐式生成一个拷贝构造函数和赋值运算符。但用户可以使用delete来指定不生成拷贝构造函数和赋值运算符，这样的对象就不能通过值传递，也不能进行赋值运算。   
③ 还有一点需要注意的是，拷贝构造函数必须以引用的方式传递参数。这是因为，在值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。

class Person
{
public:
    Person(const Person& p) = delete; //不生成拷贝构造函数
    Person& operator=(const Person& p) = delete; //不生成赋值运算符
 
private:
    int age;
    string name;
};

调用场合
① 拷贝构造函数和赋值运算符的行为比较相似，都是将一个对象的值复制给另一个对象；但是其结果却有些不同，拷贝构造函数使用传入对象的值生成一个新的对象的实例，而赋值运算符是将对象的值复制给一个已经存在的实例。这种区别从两者的名字也可以很轻易的分辨出来，拷贝构造函数也是一种构造函数，那么它的功能就是创建一个新的对象实例；赋值运算符是执行某种运算，将一个对象的值复制给另一个对象（已经存在的）。调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。如果产生了新的对象实例，那调用的就是拷贝构造函数；如果没有，那就是对已有的对象赋值，调用的是赋值运算符。拷贝构造函数是一个对象初始化一块内存区域，这块内存就是新对象的内存区，而赋值函数是对于一个已经被初始化的对象来进行赋值操作。

② 调用拷贝构造函数主要有以下场景：
对象作为函数的参数，以值传递的方式传给函数。　
对象作为函数的返回值，以值的方式从函数返回
使用一个对象给另一个对象初始化

④ 样例代码如下：
class Person
{
public:
    Person(){}
    Person(const Person& p)
    {
        cout << "Copy Constructor" << endl;
    }
 
    Person& operator=(const Person& p)
    {
        cout << "Assign" << endl;
        return *this;
    }
 
private:
    int age;
    string name;
};
 
void f(Person p)
{
    return;
}
 
Person f1()
{
    Person p;
    return p;
}
 
int main()
{
    Person p;
    Person p1 = p;    // A
    Person p2;
    p2 = p;           // B
    f(p2);            // C
 
    p2 = f1();        // D

    Person p3 = f1(); // E
 
    getchar();
    return 0;
}
Copy Constructor
Assign
Copy Constructor
Copy Constructor
Assign
Copy Constructor
判断是否是拷贝赋值函数看是否有新得对象生成，有就是拷贝。

分析如下：
A. 这是虽然使用了"="，但是实际上使用对象p来创建一个新的对象p1。也就是产生了新的对象，所以调用的是拷贝构造函数。
B. 首先声明一个对象p2，然后使用赋值运算符"="，将p的值复制给p2，显然是调用赋值运算符，为一个已经存在的对象赋值 。
C. 以值传递的方式将对象p2传入函数f内，调用拷贝构造函数构建一个函数f可用的实参。
D. 这条语句拷贝构造函数和赋值运算符都调用了。函数f1以值的方式返回一个Person对象，在返回时会调用拷贝构造函数创建一个临时对象tmp作为返回值；返回后调用赋值运算符将临时对象tmp赋值给p2.
E. 按照4的解释，应该是首先调用拷贝构造函数创建临时对象；然后再调用拷贝构造函数使用刚才创建的临时对象创建新的对象p3，也就是会调用两次拷贝构造函数。不过，编译器也没有那么傻，应该是直接调用拷贝构造函数使用返回值创建了对象p3。

深拷贝、浅拷贝：
① 通常，默认生成的拷贝构造函数和赋值运算符，只是简单的进行值的复制。例如：上面的Person类，字段只有int和string两种类型，这在拷贝或者赋值时进行值复制创建的出来的对象和源对象也是没有任何关联，对源对象的任何操作都不会影响到拷贝出来的对象。反之，假如Person有一个对象为int *，这时在拷贝时还只是进行值复制，那么创建出来的Person对象的int *的值就和源对象的int *指向的是同一个位置。任何一个对象对该值的修改都会影响到另一个对象，这种情况就是浅拷贝。

② 系统提供的默认拷贝构造函数工作方式是内存拷贝，也就是浅拷贝。如果对象中用到了需要手动释放的对象，则会出现问题，这时就要手动重载拷贝构造函数，实现深拷贝。

③ 深拷贝与浅拷贝：
浅拷贝：如果复制的对象中引用了一个外部内容（例如分配在堆上的数据），那么在复制这个对象的时候，让新旧两个对象指向同一个外部内容，就是浅拷贝。（指针虽然复制了，但所指向的空间内容并没有复制，而是由两个对象共用，两个对象不独立，删除空间存在）
深拷贝：如果在复制这个对象的时候为新对象制作了外部对象的独立复制，就是深拷贝。

④ 深拷贝和浅拷贝主要是针对类中的指针和动态分配的空间来说的，因为对于指针只是简单的值复制并不能分割开两个对象的关联，任何一个对象对该指针的操作都会影响到另一个对象。这时候就需要提供自定义的深拷贝的拷贝构造函数，消除这种影响。通常的原则是：
1.含有指针类型的成员或者有动态分配内存的成员都应该提供自定义的拷贝构造函数
2.在提供拷贝构造函数的同时，还应该考虑实现自定义的赋值运算符

⑤ 对于拷贝构造函数的实现要确保以下几点：
1.对于值类型的成员进行值复制
2.对于指针和动态分配的空间，在拷贝中应重新分配分配空间
3.对于基类，要调用基类合适的拷贝方法，完成基类的拷贝

```

#### 8.总结
拷贝构造函数和赋值运算符的行为比较相似，却产生不同的结果；拷贝构造函数使用已有的对象创建一个新的对象，赋值运算符是将一个对象的值复制给另一个已存在的对象。区分是调用拷贝构造函数还是赋值运算符，主要是否有新的对象产生。   
关于深拷贝和浅拷贝。当类有指针成员或有动态分配空间，都应实现自定义的拷贝构造函数。提供了拷贝构造函数，最后也实现赋值运算符。  

对象不存在，且没用别的对象来初始化，就是调用了构造函数；  

对象不存在，且用别的对象来初始化，就是拷贝构造函数；  

对象存在，用别的对象来给它赋值，就是赋值函数。  

对象以值传递方式从函数返回时，若接受返回值的对象已经初始化过，则会调用赋值构造函数，且该对象还会调用析构函数，当对象中包含指针时，会使该指针失效，因此需要重载赋值构造函数，使用类似深拷贝或移动构造函数的方法赋值，才能避免指针失效。

总结：   
1.拷贝构造函数实际上是构造函数的重载，具有一般构造函数的所有特性。   
2.拷贝构造就是以现有对象 构造一个新对象。赋值构造 是 现有一个对象 让他等于另一个对象。   


### <a id="2.18">C++11的bind函数</a>
可以将bind函数看作是一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。
调用bind的一般形式：auto newCallable = bind(callable,arg_list);`_1为newCallable的第一个参数，_2为第二个参数，以此类推。

#### 1.绑定普通函数
```c++
#include<iostream>
#include<functional>
using namespace std;

int plus(int a,int b)
{
   return a+b;
}
int main()
{
  //表示绑定函数plus 参数分别由调用 func1 的第一，二个参数指定
   function<int<int,int>> func1 = std::bind(plus, placeholders::_1, placeholders::_2);
   
  //func2的类型为 function<void(int, int, int)> 与func1类型一样
   auto  func2 = std::bind(plus,1,2);   //表示绑定函数 plus 的第一，二为： 1， 2 
   cout<<func1(1,2)<<endl; //3
   cout<<func2()<<endl; //3
   retunrn 0;
}
```

#### 2.绑定类的成员函数
```c++
#include<iostream>
#include<functional>
using namespace std;
class Plus
{
   public:
   	int plus(int a,int b)
   	{
   	    return a+b;
   	}
}
int main()
{
   Plus p;
   // 指针形式调用成员函数
   function<int<int,int>> func1 = std::bind(&Plus::plus,&p, placeholders::_1, placeholders::_2);
  // 对象形式调用成员函数
   function<int<int,int>> func2 = std::bind(&Plus::plus,p, placeholders::_1, placeholders::_2);
   cout<<func1(1,2)<<endl; //3
   cout<<func2(1,2)<<endl; //3
   retunrn 0;
}
占位符_1位于placeholders的命名空间，而placeholders位于std的命名空间中
```

#### 3.绑定类静态成员函数
```c++
#include<iostream>
#include<functional>
using namespace std;
class Plus
{
	public:
		static int plus(int a,int b)
		{
		    return a+b;
		}
}
int main()
{
   function<int<int,int>> func1 = std::bind(&Plus::plus, placeholders::_1, placeholders::_2);
   cout<<func1(1,2)<<endl; //3
   retunrn 0;
}
```

## <a id="3">高级</a>
- [Effective C++](#3.1)
- [More Effective c++](#3.2)
- [Google C++ Style Guide](#3.3)
- [muduo多线程网路库](#3.4)

### <a id="3.1">Effective C++</a>
1. 视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL）
2. 宁可以编译器替换预处理器（尽量以 `const`、`enum`、`inline` 替换 `#define`）
3. 尽可能使用 const
4. 确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高）
5. 了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数）
6. 若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现）
7. 为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数）
8. 别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理）
9. 绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class）
10. 令 `operator=` 返回一个 `reference to *this` （用于连锁赋值）
11. 在 `operator=` 中处理 “自我赋值”
12. 赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数）
13. 以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII））
14. 在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr））
15. 在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便）
16. 成对使用 new 和 delete 时要采取相同形式（`new` 中使用 `[]` 则 `delete []`，`new` 中不使用 `[]` 则 `delete`）
17. 以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏）
18. 让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任）
19. 设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。
20. 宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象）
21. 必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。）
22. 将成员变量声明为 private（为了封装、一致性、对其读写精确控制等）
23. 宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性）
24. 若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数
25. 考虑写一个不抛异常的 swap 函数
26. 尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率）
27. 尽量少做转型动作（旧式：`(T)expression`、`T(expression)`；新式：`const_cast<T>(expression)`、`dynamic_cast<T>(expression)`、`reinterpret_cast<T>(expression)`、`static_cast<T>(expression)`、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型）
28. 避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性）
29. 为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型）
30. 透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级）
31. 将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件）
32. 确定你的 public 继承塑模出 is-a（是一种）关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象）
33. 避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日）
34. 区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承）
35. 考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 `tr1::function` 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数）
36. 绝不重新定义继承而来的 non-virtual 函数
37. 绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound）
38. 通过复合塑模 has-a（有一个）或 “根据某物实现出”（在应用域（application domain），复合意味 has-a（有一个）；在实现域（implementation domain），复合意味着 is-implemented-in-terms-of（根据某物实现出））
39. 明智而审慎地使用 private 继承（private 继承意味着 is-implemented-in-terms-of（根据某物实现出），尽可能使用复合，当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的时候 virtual 函数，或需要 empty base 最优化时，才使用 private 继承）
40. 明智而审慎地使用多重继承（多继承比单一继承复杂，可能导致新的歧义性，以及对 virtual 继承的需要，但确有正当用途，如 “public 继承某个 interface class” 和 “private 继承某个协助实现的 class”；virtual 继承可解决多继承下菱形继承的二义性问题，但会增加大小、速度、初始化及赋值的复杂度等等成本）
41. 了解隐式接口和编译期多态（class 和 templates 都支持接口（interfaces）和多态（polymorphism）；class 的接口是以签名为中心的显式的（explicit），多态则是通过 virtual 函数发生于运行期；template 的接口是奠基于有效表达式的隐式的（implicit），多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于编译期）
42. 了解 typename 的双重意义（声明 template 类型参数是，前缀关键字 class 和 typename 的意义完全相同；请使用关键字 typename 标识嵌套从属类型名称，但不得在基类列（base class lists）或成员初值列（member initialization list）内以它作为 base class 修饰符）
43. 学习处理模板化基类内的名称（可在 derived class templates 内通过 `this->` 指涉 base class templates 内的成员名称，或藉由一个明白写出的 “base class 资格修饰符” 完成）
44. 将与参数无关的代码抽离 templates（因类型模板参数（non-type template parameters）而造成代码膨胀往往可以通过函数参数或 class 成员变量替换 template 参数来消除；因类型参数（type parameters）而造成的代码膨胀往往可以通过让带有完全相同二进制表述（binary representations）的实现类型（instantiation types）共享实现码）
45. 运用成员函数模板接受所有兼容类型（请使用成员函数模板（member function templates）生成 “可接受所有兼容类型” 的函数；声明 member templates 用于 “泛化 copy 构造” 或 “泛化 assignment 操作” 时还需要声明正常的 copy 构造函数和 copy assignment 操作符）
46. 需要类型转换时请为模板定义非成员函数（当我们编写一个 class template，而它所提供之 “与此 template 相关的” 函数支持 “所有参数之隐式类型转换” 时，请将那些函数定义为 “class template 内部的 friend 函数”）
47. 请使用 traits classes 表现类型信息（traits classes 通过 templates 和 “templates 特化” 使得 “类型相关信息” 在编译期可用，通过重载技术（overloading）实现在编译期对类型执行 if...else 测试）
48. 认识 template 元编程（模板元编程（TMP，template metaprogramming）可将工作由运行期移往编译期，因此得以实现早期错误侦测和更高的执行效率；TMP 可被用来生成 “给予政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码）
49. 了解 new-handler 的行为（set\_new\_handler 允许客户指定一个在内存分配无法获得满足时被调用的函数；nothrow new 是一个颇具局限的工具，因为它只适用于内存分配（operator new），后继的构造函数调用还是可能抛出异常）
50. 了解 new 和 delete 的合理替换时机（为了检测运用错误、收集动态分配内存之使用统计信息、增加分配和归还速度、降低缺省内存管理器带来的空间额外开销、弥补缺省分配器中的非最佳齐位、将相关对象成簇集中、获得非传统的行为）
51. 编写 new 和 delete 时需固守常规（operator new 应该内涵一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就应该调用 new-handler，它也应该有能力处理 0 bytes 申请，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”；operator delete 应该在收到 null 指针时不做任何事，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”）
52. 写了 placement new 也要写 placement delete（当你写一个 placement operator new，请确定也写出了对应的 placement operator delete，否则可能会发生隐微而时断时续的内存泄漏；当你声明 placement new 和 placement delete，请确定不要无意识（非故意）地遮掩了它们地正常版本）
53. 不要轻忽编译器的警告
54. 让自己熟悉包括 TR1 在内的标准程序库（TR1，C++ Technical Report 1，C++11 标准的草稿文件）
55. 让自己熟悉 Boost（准标准库）

### <a id="3.2">More Effective c++</a>
1. 仔细区别 pointers 和 references（当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 references；任何其他时候，请采用 pointers）
2. 最好使用 C++ 转型操作符（`static_cast`、`const_cast`、`dynamic_cast`、`reinterpret_cast`）
3. 绝不要以多态（polymorphically）方式处理数组（多态（polymorphism）和指针算术不能混用；数组对象几乎总是会涉及指针的算术运算，所以数组和多态不要混用）
4. 非必要不提供 default constructor（避免对象中的字段被无意义地初始化）
5. 对定制的 “类型转换函数” 保持警觉（单自变量 constructors 可通过简易法（explicit 关键字）或代理类（proxy classes）来避免编译器误用；隐式类型转换操作符可改为显式的 member function 来避免非预期行为）
6. 区别 increment/decrement 操作符的前置（prefix）和后置（postfix）形式（前置式累加后取出，返回一个 reference；后置式取出后累加，返回一个 const 对象；处理用户定制类型时，应该尽可能使用前置式 increment；后置式的实现应以其前置式兄弟为基础）
7. 千万不要重载 `&&`，`||` 和 `,` 操作符（`&&` 与 `||` 的重载会用 “函数调用语义” 取代 “骤死式语义”；`,` 的重载导致不能保证左侧表达式一定比右侧表达式更早被评估）
8. 了解各种不同意义的 new 和 delete（`new operator`、`operator new`、`placement new`、`operator new[]`；`delete operator`、`operator delete`、`destructor`、`operator delete[]`）
9. 利用 destructors 避免泄漏资源（在 destructors 释放资源可以避免异常时的资源泄漏）
10. 在 constructors 内阻止资源泄漏（由于 C++ 只会析构已构造完成的对象，因此在构造函数可以使用 try...catch 或者 auto_ptr（以及与之相似的 classes） 处理异常时资源泄露问题）
11. 禁止异常流出 destructors 之外（原因：一、避免 terminate 函数在 exception 传播过程的栈展开（stack-unwinding）机制种被调用；二、协助确保 destructors 完成其应该完成的所有事情）
12. 了解 “抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异（第一，exception objects 总是会被复制（by pointer 除外），如果以 by value 方式捕捉甚至被复制两次，而传递给函数参数的对象则不一定得复制；第二，“被抛出成为 exceptions” 的对象，其被允许的类型转换动作比 “被传递到函数去” 的对象少；第三，catch 子句以其 “出现于源代码的顺序” 被编译器检验对比，其中第一个匹配成功者便执行，而调用一个虚函数，被选中执行的是那个 “与对象类型最佳吻合” 的函数）
13. 以 by reference 方式捕获 exceptions（可避免对象删除问题、exception objects 的切割问题，可保留捕捉标准 exceptions 的能力，可约束 exception object 需要复制的次数）
14. 明智运用 exception specifications（exception specifications 对 “函数希望抛出什么样的 exceptions” 提供了卓越的说明；也有一些缺点，包括编译器只对它们做局部性检验而很容易不经意地违反，与可能会妨碍更上层的 exception 处理函数处理未预期的 exceptions）
15. 了解异常处理的成本（粗略估计，如果使用 try 语句块，代码大约整体膨胀 5%-10%，执行速度亦大约下降这个数；因此请将你对 try 语句块和 exception specifications 的使用限制于非用不可的地点，并且在真正异常的情况下才抛出 exceptions）
16. 谨记 80-20 法则（软件的整体性能几乎总是由其构成要素（代码）的一小部分决定的，可使用程序分析器（program profiler）识别出消耗资源的代码）
17. 考虑使用 lazy evaluation（缓式评估）（可应用于：Reference Counting（引用计数）来避免非必要的对象复制、区分 operator[] 的读和写动作来做不同的事情、Lazy Fetching（缓式取出）来避免非必要的数据库读取动作、Lazy Expression Evaluation（表达式缓评估）来避免非必要的数值计算动作）
18. 分期摊还预期的计算成本（当你必须支持某些运算而其结构几乎总是被需要，或其结果常常被多次需要的时候，over-eager evaluation（超急评估）可以改善程序效率）



### <a id="3.3">Google C++ Style Guide</a>
英文：Google C++ Style Guide  
https://google.github.io/styleguide/cppguide.html  
中文：C++ 风格指南   
https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/   

  
<img src="./image/1-2.png" style="zoom:100%" />

### <a id="3.4">muduo多线程网路库</a>
1. Boost::function不对类型和函数名做限制，只对参数和返回类型做部分限制。如果你通过传统的继承来回调的话，你这个类型必须是framework里某个基类的派生类，函数的名字必须一样，参数列表必须一样，返回类型也基本肯定是一样。但是boost::function没有这些限制。
2. 很多class比如map string都不是线程安全。可重入代表可中断，在线程之间切换。线程安全不要再构造期间泄露this指针避免还没构建好就使用了即使最后一行也不行，基类优先派生类创建执行完还得指向派生类构造函数。一般靠构造函数+initialize，构造好之后通过initialize的返回值判断对象是否构造成功简化错误处理。
3. mutex只能保证函数一个接一个的执行。如果是多线程可能在析构函数中删除mutex导致另外一个线程一直阻塞。mutex保证对象读和写，在集类析构后派生类已析构了。基类的mux不能保护整个析构过程。
4. 对象关系主要有三种：组合、关联、聚合。组合：多线程没啥问题，对象由唯一拥有者控制。关联：一个对象用另外一个对象调用后者成员函数。聚合和关联形式相同。为了避免析构不安全，可以只创建不销毁，使用对象池有存货使用，否则创建。
5. 多线程中销毁对象需要注意。两个指针p1 p2指向一个对象，通过p1将对象销毁，p2变成空指针。解决空指针方法引入中间proxy对象。指向object如果通过销毁object proxy存在，查看proxy判断object是否存在，也不会变成空指针。是否proxy指针也会有race condtion。更安全方式是引用计算，p1p2变成对象sp1sp2，proxy有两个对象指针计数，sp1sp2析构后 引用计算为0才能进行删除。shared_ptr weak_ptr。如果多个shared_ptr指向对象，只要有一个指向对象shared_ptr存在对象都不会被销毁。weak_ptr知道对象还活着，如果对象活着为有效shared_ptr，对象死了返回空的shared_ptr。shared_ptr引用计数本身安全无锁, 对象读写不是读写不安全。可以被多个线程读写，读写同一个对象需要加锁。shared_ptr允许拷贝构造和赋值，函数入参拷贝，遗漏一个拷贝永世长存，通常采用&常引用，不比拷贝。
6. weak_ptr指向stock[key]如果不存在默认创建一个，shared_ptr=weak_ptr.lock()，将弱变强引用。判断shared_ptr是否为空，不为空就将shared_ptr置空，更新weak_ptr。
7. 利用shared_ptr定制析构函数，传入函数指针或者仿函数进行del。boost：bind。
8. enable_shared_from_this，获得指向当前对象得指针返回shared_ptr。不能在构造函数里面调用，还没有被shared接管。
9. 弱回调在回调中尝试提升shared-ptr，提升成功接受调用对象还在，执行回调，提示失败不存在。weak shared完美解决两个对象相互引用问题。谁挂掉都不会影响。除了这种方式还可以用代理方式。
10. 尽量不使用读写锁，后期更新变化不方便。可重入不可重入区别。尽量不使用信号量可以用锁加条件变量配合代替，信号量保存计数量会与代码中数据结结构中长度重复，维护困难。
11. 线程等待有两种，一种是等待资源可用select poll epoll 一种是等待进入临界区mutex。
12. shared_ptr.unique()函数检查是否是独一得，判断是否有人在读。shared_ptr可以通过reset方法重置指向另一个对象，此时原对象的引用计数减一。
13. 进程共享代码段，线程共享数据。pthreda——exit退出线程，pthread-cancel其他线程强制终止线程。用pid唯一作为缓存。pthrad-once执行一次。pthread-self返回当前进程标识符，pthread-equal比较标识符相等。尽量不要用exit cancel避免资源未清理，可以用杀进程方法，用文件描述符来收发数据避免死锁。
14. exit(3)终止进程还会析构全家对象何构造好得函数静态对象，所以有潜在死锁。__thread无法修饰class，无法自动调用构造函数析构函数，每一个线程都有一个独立实体各个线程互不打扰。
15. 因为磁盘都有操作对象，多线程读写请求，到了内核也是要是排队执行，所以多线程优势没体现，除非内核缓存大部分数据。多线程尽量：每一个文件操作符由一个线程操作，一个线程可以操作多个文件描述符，一个线程不能操作别的线程fd。这条准则两个例外，1.pread、pwrite读写同一个文件。2.udp多个线程读写同一个udp fd。保证不串socket，创建后再将close放在析构里面。只要socket对象活着，就不会有其他socket和他一样fd。服务端不应该关闭fd 1 2 our err，重定向到磁盘文件，避免被占用。
16. fork一般不在多线程中调用，只克隆当前线程线程控制，不克隆其他线程。除了当前线程其他线程都消失了。一般是fork之后执行exec执行另一个程序，阻断父子进程关系。
17. 信号与多线程不搭，信号分为两种：1.是发送给一线程2发送给进程任一线程。
18. 多线程中使用signal不要使用signal，包含ipc，signal定时器等。
19. 多线程写和数据队列都有限速。日志定期缓存或者内存数据带cookir。磁盘有速度和业务读写数据要1：9。优化日志可以将固定部分写死减少开销。一个线程收集日志，其他线程网日志线程发送日志信息，异步日志也叫非阻塞日志。io网络和读写阻塞回影响请求速度。业务线程避免磁盘io影响客户连接。可以准备两个缓存一个写日志信息，一个用于写文件，如果写满则进行交换。
20. tcp编程方式可以用回调，一个收数据的回调，收到数据会调用，一个注册接受连接回调，接受新的连接回调。tcp网络编程本质问题：1、连接建立tcp建立连接平等，可以各自收发数据，2、连接断开主动断开close、shutdown，被动断开read返回0。3、消息到达fd可读分包缓存等、4、消息发送完毕负责发送重传。中间很多难点注意：主动关闭确对方收到数据。缓冲区解决阻塞发送问题。可以注册回调函数处理前面说得问题。
21. 单线程可以并连多个客户端，分布不同的进程占用不同的端口，需要前端进行负载均衡。
22. 并发网络设计方案：0、一次只服务一个客户端while循环accept等待结束处理。1、fork进程进行并发，适合响应工作量大于fork开销得，因为fork开销时间长。适合长连接。2、多线程并发开销比多进程小，但也不适合短连接，也受线程数限制。3、prefork是针对1得优化对accpet惊群考虑。4、prethread方案2优化，方案34都是apache httpd长期使用方案。以上都是阻塞式网络编程，阻塞read上导致stdio和网络阻塞。解决方法：a、两个线程或者进程一个读一个写。b、采用select poll epoll等多路选择。socket到fd得映射，有io事件针对不同fd执行不同得操作，有listen接受accept就添加到事件fd监听中。如果只有一个线程处理需要注意每一次poll到来抢占问题。应该有注册超时回调。5、单线程reactor方案即上面说得，优点网络库负责收发程序只管逻辑缺点适合io密集不适合cpu密集，不发挥多核特性。比方案2多了一次poll。6、过渡方案，收到请求不在reactor线程计算，创建新线程计算初级多线程应用。可以用线程池规避就是方案8。缺点式多线程计算同连接上次序问题。7、为每一个连接创建计算线程，每个连接上请求固定发向同一个线程去算。7和6区别是一个是一开始就线程一个是接受连接多线程。区别是6中一个tcp连接一长串请求会占满8个cpu，7只会一个cpu。8、弥补方案6每一个请求创建线程采用线程池，io在reactor线程里，计算任务交给thread pool。线程池另外一个作用是执行阻塞操作。9、如果io较大一个reactor处理不过来可以采用多个reactor。不采用线程池避免上下文切换。10、nginx方案，将reactor放在进程中，如果连接之间无交互比较好。11、方案89得结合，就有多个reactor处理io，即用线程池处理计算，即能处理突发io和突发计算。总结：5方案之后是io和计算分开，比喻成银行中旋转门+柜台。
23. tcp是流数据，需要进行分包。分包四种方法：1、消息长度固定。2、使用特殊字符或者字符串作为消息边界。http使用\r\n字符分割符。3、消息头部加上长度最常见做法。4、消息本时格式进行分包比如xml。
24. 核心思想就是避免阻塞再read write等系统调用上，只能阻塞在io复用上比如select poll等。必须要有outbuffer，可能发送100kb系统只接受80为了不等，需要放在buffer，注册pollout。一旦socket可读就立刻发送数据。写完就停止关注pollout事件。采用的是level trigger。如果buffer有数据，关闭连接需要等buffer数据发送完再close。当socket可读，必须一次性把系统数据搬到应用层buffer，否则会反复触发pollin。为什么采用level trigger为了和传统poll(2)匹配。
25. buffer设计两块内存，一个读一个临时栈extrabuff，如果读入数据不多就用第一个。这样避免每个连接初始buff过大。buffer不是线程安全，因为每一个线程操作一个buffer。用到readindex writeindex readable writeable preappend。使用vector使用capcity可以减少内存分配次数。连接数乘以头部即吞吐量。相对而言ddr内存读取比网络快。
26. protobuf序列化的二进制流数据，类型或者长度需要提前约定好，根据type name反射创建具体类型message对象。
27. 定时器常见任务：1、获取当前时间计算时间间隔。2、时区转换和日期计算。3、定时操作预定时间执行任务。计时和定时两种，计时gettimeofdat获取当前时间，timerfd_create系列函数处理定时任务。gettimeofday精度合适用户态，timerfd_create把时间变成一个文件描述符，容易融入select等。
28. 踢掉空闲连接一种是定时遍历查看当前时间与最后一次接受数据时间比较大于8s就踢掉连接缺点是费时。一种是每个连接设置超时回调缺点是每个都有对eventloop有压力。比较好的是time wheel，第一个1s之后超时得。采用shareptr引用计数。
29. 转发relay服务需要考虑什么时候连接，并发连接管理传话，连接断开主动，网络速度不匹配等问题1对多，多对一，socket代理。socket4a协议可参考。多对1是multiplexer，一对多是backend，sock是sockes4a。
30. channel对象只属于一个eventloop只属于一个线程，只负责一个文件描述符的io时间分发，会把不同的io发给不同的回调。因为chanel内部调用就不需要加锁。poll类总有fd到channel的channel map映射。loop包含pool包含chanel map 对应fd对应callback。poll update channle。poll获得当前活动的channle，依次调用每一个channle 的hanele event。如果发送时候不在当前线程进行判断后move到复制后传给线程中sendinloop发送，效率低点但是安全，move避免内存拷贝。
31. write写入数据非阻塞和阻塞两种，如果写入过大，超过内核大小。阻塞会等下次发送，非阻塞会返回缓冲区是满的，则返回-1，并置error值为EAGAIN 或 EWOULDBLOCK。sigpipe默认是终止进程，对方断开连接本地继续写入会造成服务进程意外退出。解决方式忽略sigpipi。signl（sigpipe，sig_ign）.需要暴露出no delay，关闭nagle和keepalive 探测连接。setsocketopt。
32. 发送困难：1.什么时候发，2.发送速度匹配。高水位回调和低水位回调。心跳需要在发送和收到周期与超时进行比较，但是不能太长太长敏感，太短频繁。心跳线程中发送与业务消息同一个连接。防止伪心跳。线程卡死心跳也要卡死避免不同步。分布式进程标识符要和所有进程区别重启后不一样避免搭错话。
33. 向前声明就是定义在使用之前，c++可以在使用前使用class foo这样向前声明，避免暴露。重载返回值不一样报错。inline自动判断，会在检查后在判断。
34. 模板分为函数模板和类模板，与连接相关有函数定义与变量定义。模板编译连接对象可能会在多个编译单元被定义，链接需要进行重复代码消除。会在每一个用到类模板成员函数具现化一个实体。头文件放模板得定义和声明避免编译链接失败。include就是在预编译时候将目标源内容复制到当前内容。头文件是将声明包含进去避免依赖。类模板函数实现在源文件中？不是很懂。libstdc++是c++标准库 glibc是c标准库。
35. 不要用虚函数作为库接口，库升级避免接口变化。使用虚函数因为是偏移所以修改后会变地址除非放在最后或者继承类或者多从继承。
36. boost::function<void()>  f1;f1=boost::bind(&foo::metha,&foo,42);，没有bind function什么都不是。有了bind就可以一个类不同对象给不同得实列不同行为。
37. printf安全性不友好等原因，答应type类型需要转换成long用ld打印。int64_t在32 64不通类型需要inttype头文件。iiostream是对象禁止构造拷贝，释放会出现问题。snprintf或者stringstream打印到缓存，再到ostream。coutab，相当于两次，一般再多线程用printf。
38. 值语义和对象语义。值语义或者数据抽象指的是对象得拷贝和对象无关就像int char bool vector map pair等一样。对象语义或者引用语义是面对对象意义下得对象，对象拷贝是禁止得，拷贝一个线程不能增加一个一模一样得线程。值语义生命管理简单要不栈对象要不就是成员不比担心生命周期，对象语义不能拷贝只能通过指针或者引用来使用它。scoped_ptr智能指针将对象引用变成值引用解决生命周期问题，不比担心释放问题。互相引用对象一个是weak看具体情况。定义对象时，用强智能指针shared_ptr，在其它地方引用对象时，使用弱智能指针weak_ptr。
39. namespace不利于调试。为了版本管理注释变量定义参数多行显示。next_permutation函数排列，unique函数去重，makepushpop_heap排序多路并归。partition符合条件放到区间首部。
40. 每个连接至少要占用一个文件描述符，dup fork会导致多个fd对应一个连接。并发连接受限于fd最大值。并发上线是2得48次方，受限于全局fd和内存。每个客户端上线是2得32次方个，每个客户IP上限是2得16次方。
41. 使用Linux epoll模型，水平触发模式；当socket可写时，会不停的触发 socket 可写的事件，如何处理？
第一种最普遍的方式：
需要向 socket 写数据的时候才把 socket 加入 epoll ，等待可写事件。
接受到可写事件后，调用 write 或者 send 发送数据。。。
当所有数据都写完后，把 socket 移出 epoll。 
这种方式的缺点是，即使发送很少的数据，也要把 socket 加入 epoll，写完后在移出 epoll，有一定操作代价。
一种改进的方式：
开始不把 socket 加入 epoll，需要向 socket 写数据的时候，直接调用 write 或者 send 发送数据。
如果返回 EAGAIN，把 socket 加入 epoll，在 epoll 的驱动下写数据，全部数据发送完毕后，再出 epoll。
这种方式的优点是：数据不多的时候可以避免 epoll 的事件处理，提高效率。
42. mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutalbe来修饰。const函数中使用mutable来修改变量得值。

## links
  * [目录](<目录.md>)
