# 网络编程
- [socket编程](#1)
- [socket高级编程](#2)
 - [Linux关于阻塞和非阻塞](#2.1)
 - [阻塞模式和粘包问题](#2.2)
- [TCP/IP基础](#3)
 - [TCP/UDP头](#3.1)
 - [IP头](#3.2)
 - [TCP带外数据](#3.3)
 - [TCP数据包重组实现分析](#3.4)

## <a id="1">socket编程</a>

## <a id="2">socket高级编程</a>
- [Linux关于阻塞和非阻塞](#2.1)
- [阻塞模式和粘包问题](#2.2)

### <a id="2.1">Linux关于阻塞和非阻塞</a>
参考链接：  
1.Linux关于阻塞和非阻塞    
https://blog.csdn.net/qq_42270373/article/details/89527454  

阻塞IO：socket 的阻塞模式意味着必须要做完IO 操作（包括错误）才会 返回。

非阻塞IO：非阻塞模式下无论操作是否完成都会立刻返回，需要通过其他方式来判断具体操作是否成功。(对于connect，accpet操作，通过select判断，对于recv，recvfrom，send，sendto通过返回值+错误码来判断)

IO模式设置：  
一般对于一个socket 是阻塞模式还是非阻塞模式有两种方式  
- 方法1：用fcntl 设置;用F_GETFL获取flags,用F_SETFL设置flags|O_NONBLOCK;；
- 方法:2：recv/send 时使用非阻塞的方式读取和发送消息，即把flags设置为MSG_DONTWAIT 实现(临时将sockfd或filefd设置为非阻塞)

#### 方法1
```cpp
fcntl 函数可以将一个socket 句柄设置成非阻塞模式:

flags = fcntl(sockfd, F_GETFL, 0); //获取文件的flags值。
fcntl(sockfd, F_SETFL, flags | O_NONBLOCK); //设置成非阻塞模式；
flags = fcntl(sockfd,F_GETFL,0);
fcntl(sockfd,F_SETFL,flags&~O_NUNBLOCK); //设置成阻塞模式；
设置之后每次的对于sockfd 的操作都是非阻塞的。
```

#### 方法2
```cpp
recv, send 函数的最后有一个flag 参数可以设置成MSG_DONTWAIT，临时将sockfd 设置为非阻塞模式,而无论原有是阻塞还是非阻塞：
recv(sockfd, buff, buff_size,MSG_DONTWAIT); //非阻塞模式的消息发送
send(scokfd, buff, buff_size, MSG_DONTWAIT); //非阻塞模式的消息接受
```

阻塞与非阻塞读的区别: //阻塞和非阻塞的区别在于没有数据到达的时候是否立刻返回．
非阻塞IO 和阻塞IO：在网络编程中对于一个网络句柄会遇到阻塞IO 和非阻塞IO 的概念, 这里对于这两种socket 先做一下说明：

    普通文件:
    对于文件的阻塞模式还是非阻塞模式::
    方法1、open时，使用O_NONBLOCK；
    方法2、fcntl设置，使用F_SETFL，flags|O_NONBLOCK；

    消息队列:
    对于消息队列消息的发送与接受
    非阻塞  msgsnd(sockfd,msgbuf,msgsize(不包含类型大小),IPC_NOWAIT)
    阻塞    msgrcv(scokfd,msgbuf,msgsize(**),msgtype,IPC_NOWAIT);     

#### 读
阻塞与非阻塞读的区别: //阻塞和非阻塞的区别在于没有数据到达的时候是否立刻返回．

读(read/recv/msgrcv):
读的本质来说其实不能是读,在实际中, 具体的接收数据不是由这些调用来进行,是由于系统底层自动完成的。read 也好,recv 也好只负责把数据从底层缓冲copy 到我们指定的位置。

在阻塞条件下：  
read/recv/msgrcv的行为，如果没有发现数据在网络缓冲中会一直等待，当发现有数据的时候会把数据读到用户指定的缓冲区，但是如果这个时候读到的数据量比较少，比参数中指定的长度要小，read 并不会一直等待下去，而是立刻返回。

read 的原则：是数据在不超过指定的长度的时候有多少读多少，没有数据就会一直等待。
所以一般情况下：我们读取数据都需要采用循环读的方式读取数据，因为一次read 完毕不能保证读到我们需要长度的数据，
read 完一次需要判断读到的数据长度再决定是否还需要再次读取。

非阻塞情况下：  
在非阻塞的情况下，read 的行为：
1、如果发现没有数据就直接返回
2、如果发现有数据那么也是采用有多少读多少的进行处理所以read 完一次需要判断读到的数据长度再决定是否还需要再次读取。

对于读而言，阻塞和非阻塞的区别在于没有数据到达的时候是否立刻返回．
recv 中有一个MSG_WAITALL 的参数

recv(sockfd, buff, buff_size, MSG_WAITALL),  

在正常情况下recv 是会等待直到读取到buff_size 长度的数据，但是这里的WAITALL 也只是尽量读全，在有中断的情况下recv 还是可能会被打断，造成没有读完指定的buff_size的长度。所以即使是采用recv + WAITALL 参数还是要考虑是否需要循环读取的问题，在实验中对于多数情况下recv (使用了MSG_WAITALL)还是可以读完buff_size，所以相应的性能会比直接read 进行循环读要好一些。

>注意：   
使用MSG_WAITALL时，sockfd必须处于阻塞模式下，否则不起作用。  
所以MSG_WAITALL不能和MSG_NONBLOCK同时使用。  
要注意的是使用MSG_WAITALL的时候，sockfd 必须是处于阻塞模式下，否则WAITALL不能起作用。  

#### 写
阻塞写与非阻塞写的区别  
写(send/write/msgsnd)：写的本质也不是进行发送操作,而是把用户态的数据copy 到系统底层去,然后再由系统进行发送作send，write返回成功，只表示数据已经copy 到底层缓冲,而不表示数据已经发出,更不能表示对方端口已经接收到数据，对于write(或者send)而言，阻塞情况下，write会将数据发送完。(不过可能被中断)  在阻塞的情况下，是会一直等待，直到write 完全部的数据再返回，这点行为上与读操作有所不同，原因是：  

读，究其原因主要是读数据的时候我们并不知道对端到底有没有数据，数据是在什么时候结束发送的，如果一直等待就可能会造成死循环，所以并没有去进行这方面的处理；

写，而对于write, 由于需要写的长度是已知的，所以可以一直再写，直到写完．不过问题是write 是可能被打断吗，造成write 一次只write 一部分数据, 所以write 的过程还是需要考虑循环write, 只不过多数情况下一次write 调用就可能成功.

非阻塞写的情况下  
非阻塞写的情况下，是采用可以写多少就写多少的策略．与读不一样的地方在于，有多少读多少是由网络发送的那一端是否有数据传输到为标准，但是对于可以写多少是由本地的网络堵塞情况为标准的，在网络阻塞严重的时候，网络层没有足够的内存来进行写操作，这时候就会出现写不成功的情况，阻塞情况下会尽可能(有可能被中断)等待到数据全部发送完毕， 对于非阻塞的情况就是一次写多少算多少,没有中断的情况下也还是会出现write 到一部分的情况.  

### <a id="2.2">阻塞模式和粘包问题</a>
参考链接：  
1.TCP套接字--阻塞模式和粘包问题  
https://www.cnblogs.com/straybirds/p/9472157.html  

阻塞模式  
对于TCP套接字（默认情况下），当使用 write()/send() 发送数据时：
- 1) 首先会检查缓冲区，如果缓冲区的可用空间长度小于要发送的数据，那么 write()/send() 会被阻塞（暂停执行），
直到缓冲区中的数据被发送到目标机器，腾出足够的空间，才唤醒 write()/send() 函数继续写入数据。
- 2) 如果TCP协议正在向网络发送数据，那么输出缓冲区会被锁定，不允许写入，write()/send() 也会被阻塞，
直到数据发送完毕缓冲区解锁，write()/send() 才会被唤醒。
- 3) 如果要写入的数据大于缓冲区的最大长度，那么将分批写入。
- 4) 直到所有数据被写入缓冲区 write()/send() 才能返回。

当使用 read()/recv() 读取数据时：
- 1) 首先会检查缓冲区，如果缓冲区中有数据，那么就读取，否则函数会被阻塞，直到网络上有数据到来。
- 2) 如果要读取的数据长度小于缓冲区中的数据长度，那么就不能一次性将缓冲区中的所有数据读出，
剩余数据将不断积压，直到有 read()/recv() 函数再次读取。
- 3) 直到读取到数据后 read()/recv() 函数才会返回，否则就一直被阻塞。
这就是TCP套接字的阻塞模式。所谓阻塞，就是上一步动作没有完成，下一步动作将暂停，直到上一步动作完成后才能继续，以保持同步性。

TCP套接字默认情况下是阻塞模式，也是最常用的。当然你也可以更改为非阻塞模式。

#### TCP粘包问题和数据无界性
上面讲到了socket缓冲区和数据的传递过程，可以看到数据的接收和发送是无关的，read()/recv() 函数不管数据发送了多少次，
都会尽可能多的接收数据。也就是说，read()/recv() 和 write()/send() 的执行次数可能不同。

例如，write()/send() 重复执行三次，每次都发送字符串"abc"，那么目标机器上的 read()/recv() 可能分三次接收，
每次都接收"abc"；也可能分两次接收，第一次接收"abcab"，第二次接收"cabc"；也可能一次就接收到字符串"abcabcabc"。

假设我们希望客户端每次发送一位学生的学号，让服务器端返回该学生的姓名、住址、成绩等信息，这时候可能就会出现问题，服务器端不能区分学生的学号。
例如第一次发送 1，第二次发送 3，服务器可能当成 13 来处理，返回的信息显然是错误的。

这就是数据的“粘包”问题，客户端发送的多个数据包被当做一个数据包接收。
也称数据的无边界性，read()/recv() 函数不知道数据包的开始或结束标志（实际上也没有任何开始或结束标志），
只把它们当做连续的数据流来处理。

## <a id="3">TCP/IP基础</a>
 - [TCP/UDP头](#3.1)
 - [IP头](#3.2)
 - [TCP带外数据](#3.3)
 - [TCP数据包重组实现分析](#3.4)

### <a id="3.1">TCP/UDP头</a>

### <a id="3.2">IP头</a>

### <a id="3.3">TCP带外数据</a>
参考链接：  
1.TCP 带外数据（即紧急模式的发送和接受）  
https://blog.csdn.net/liushengxi_root/article/details/82563181  

首先，我们需要知道的是数据分为两种，一种是带内数据，一种是带外数据。带内数据就是我们平常传输或者说是口头叫的数据。带外数据就是我们接下来讲的内容。

许多的传输层都具有带外数据（也称为 经加速数据 ）的概念，想法就是连接的某段发生了重要的事情，希望迅速的通知给对端。这里的迅速是指这种通知应该在已经排队了的带内数据之前发送。也就是说，带外数据拥有更高的优先级。带外数据不要求再启动一个连接进行传输，而是使用已有的连接进行传输。 其中，UDP没有实现带外数据（是个极端哦～）

<img src="./image/4-1.png" style="zoom:100%" />

针对标题，我们自然只关心以下两个部分：  
紧急字段URG：告诉系统此报文段中有紧急数据，应尽快传送。当URG=1时。
紧急指针：指出在本报文段中的紧急数据的最后一个字节的序号，即指出带外数据字节在正常字节流中的位置。

所以当TCP发送带外数据时，他的TCP首部一定是设置了URG标志和紧急指针的 。而紧急指针就是用来指出带外数据字节在正常字节流中的位置的 。

#### 发送端
- 1.紧急数据是插在正常数据流中进行传输的 。

- 2.一个紧急指针只指向一个字节的带外数据的后一个字节位置。比如我们要发送数据1，2，3，4，5，6 ，7，8，如果我们只发送一个字节的带外数据X，那么发送缓冲区就是（1，2，3，4，5，6，7，8，X），紧急指针置为10，X是带外数据字节 。如果我们发送多个字节的带外数据（X，Y，Z），那么发送缓冲区就是（1，2，3，4，5，6，7，8，X，Y，Z），紧急指针指向Z的后面，为12 ，Z 被当作带外数据字节。

- 3.假如由于发送窗口的关系，导致该发送缓冲区中的数据（1，2，3，4，5，6，7，8，X）分为多次或者两次发送。比如：发送窗口是6，那么就分为两个包发送，情况如下：第一个包紧急指针为10，传送六个字节（1,2,3,4,5,6），接收端记下接受的字节数并且发现紧急指针指向的紧急数据没有到达，所以继续等待下一个包，下一个包（紧急指针还是10）发过来 7,8,X ，接收端发现紧急指针指向的紧急数据在这个包里，所以将紧急数据进行处理即可。

- 4.带外字节会被标记为OOB

- 5.即使发送端TCP因流量控制而暂停发送数据（接受缓冲区的套接字接受缓冲区已满，导致其TCP向发送端通告了一个值为0 的窗口），紧急通知照样不伴随任何数据的发送。也就是说：即使数据的流动会因为TCP的流量控制而停止，紧急通知却总是无障碍的发送到对端TCP。

#### 接受端
一旦有一个新的紧急指针到达，不论由紧急指针指向的实际数据字节是否已经到达接受端，以下两个动作都会发生 ：
- 1.当接受到一个设置了URG标志的分节时，接受端检查紧急指针，确定它是否指向新的带外数据，比如：前面发送了两个包，只有第一个才会通知接受进程有新的带外数据到达。

- 2.当有新的紧急指针到达时，接受进程被通知到。首先，内核会给接受套接字的属主进程发送SIGURG信号，前提是接受进程调用了 fcntl或者ioctl为这个套接字建立了属主，并且该属主进程为该信号建立了信号处理函数 。

- 3.只有一个OOB标记，如果新的OOB字节在旧的OOB字节之前到达，旧的OOB字节就会被丢弃。

- 4.当由紧急指针指向的实际数据字节到达接受端TCP时，数据字节会有两个存储地区：一个是和普通数据一样的在线留存，另外一个是独立的单字节带外缓冲区，接受进程从这个单字节带外缓冲区读入数据的唯一方法是指定MSG_OOB调用recv，recvfrom，recvmsg。如果放在和普通数据一起的带内区域，接受进程就得通过检查该连接的带外标记OOB来获悉何时访问带这个数据字节。两个区域的使用通过套接字选项SO_OOBLINE来使用，默认情况下将带外数据字节放入独立的单字节带外缓冲区内。

#### 会发生的一些错误
- 1.如果接受进程请求读入数据（通过MSG_OOB标志），但是对端并没有发送任何带外数据，读入操作将返回EINVAL。

- 2.在接受进程已被告知对端发送了一个带外字节（SIGURG和select）的前提下，如果接受进程试图读入该字节，但是该字节尚未到达，读入操作返回EWOULDBLOCK。接受进程此时做的就是从缓冲区中读入数据，腾出空间，以允许对端TCP发送出那个带外字节。

- 3.如果接受进程试图多次读入同一个带外字节，读入操作返回EINVAL。

- 4.如果开启了SO_OOBINLINE套接字选项，接受进程如果还是通过MSG_OOB读入带外数据，读入操作将返回EINVAL 。

#### 为何不直接将一个字节的紧急数据放在紧急指针哪里呢？
   因为TCP数据包在ip层可能被拆包，成为多个数据段。一个包含紧急数据的数据包被拆成两个数据包，那么这两个包有的tcp头部有相同的紧急指针（和UGR）。如果将紧急数据直接放在紧急指针的内存处，那么将多出一个紧急数据！所以，不该将紧急数据放在TCP头部。

#### 总结
带外数据概念实际上时向接收端传送三个不同的信息：
- （1）发送端进入紧急模式这个事实。接收进程得以通知这个事实的手段不外乎SIGURG信号或select调用。本通知在发送进程发送带外字节后由发送端TCP立即发送，即使往接收端的任何数据发送因流量控制而停止了，TCP仍然发送本通知。本通知可能导致接收端进入某种特殊处理模式，以处理接收的任何后继数据。
- （2）带外字节的位置，也就是它相对于来自发送端的其余数据的发送位置：带外标记。
- （3）带外字节的实际值。既然TCP是一个不解释应用进程所发送数据的字节流协议，带外字节就可以是任何8位值。

对于TCP的紧急模式，我们可以认为URG标志时通知（信息1），紧急指针是带外标记（信息2），数据字节是其本身（信息3）。
与这个带外数据概念相关的问题有：
- 每个连接只有一个TCP紧急指针；
- 每个连接只有一个带外标记；
- 每个连接只有一个单字节的带外缓冲区（该缓冲区只有在数据非在线读入时才需考虑）。如果带外数据时在线读入的，那么当心的带外数据到达时，先前的带外字节字节并未丢失，不过他们的标记却因此被新的标记取代而丢失了。

   带外数据的一个常见的用途体现在rlogin程序中。当客户中断运行在服务器主机上的程序时，服务器需要告知客户丢弃所有已在服务器排队的输出，因为已经排队等着从服务器发送到客户的输出最多有一个窗口的大小。服务器向客户发送一个特殊字节，告知后者清刷所有这些输出（在客户看来是输入），这个特殊字节就作为带外数据发送。客户收到由带外数据引发的SIGURG信号后，就从套接字中读入直到碰到带外数据发送。客户收到由带外数据引发的SIGURG信号后，就从套接字中读入直到碰到带外标记，并丢弃到标记之前的所有数据。这种情形下即使服务器相继地快速发送多个带外字节，客户也不受影响，因为客户只是读到最后一个标记为止，并丢弃所有读入的数据。

   总之，带外数据是否有用取决于应用程序使用它的目的。如果目的是告知对端丢弃直到标记处得普通数据，那么丢失一个中间带外字节及其相应的标记不会有什么不良后果。但是如果不丢失带外字节本身很重要，那么必须在线收到这些数据。另外，作为带外数据发送的数据字节应该区别于普通数据，因为当前新的标记到达时，中间的标记将被覆写，从而事实上把带外字节混杂在普通数据之中。举例来说，telnet在客户和服务器之间普通的数据流中发送telnet自己的命令，手段是把值为255的一个字节作为telnet命令的前缀字节。（值为255的单个字节作为数据发送需要2个相继地值为255的字节。）这么做使得telnet能够区分其命令和普通用户数据，不过要求客户进程和服务器进程处理每个数据字节以寻找命令。

### <a id="3.4">TCP数据包重组实现分析</a>
参考链接：  
1.TCP数据包重组实现分析  
https://blog.csdn.net/wfqxx/article/details/4246634?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase  

参照TCP/IP详解第二卷24~29章，详细论述了TCP协议的实现，大概总结一下TCP如何向应用层保证数据包的正确性、可靠性，即TCP如何实现对数据报文的重组。

首先要设计两个报文队列，一个存放正常来到的报文，一个存放失序到来的报文。

比如正常报文队列最后一个报文数据如下：

报文数据段第一字节的序号 | 数据报长度  
-|-
seq1=100 | len1=100 |

下一个来到的报文可能有多种情况，现依次分析如下：  
1）正常报文

序号 | 数据报长度  
-|-
seq2=200 | len2=200 |

seq2 = seq1+len1  
由此报文的seq可知，这个报文携带数据序号200~399，正是上一个报文的预期后续报文，将此报文追加到正常报文队列。  

2）完全重复报文

序号 | 数据报长度  
-|-
seq2=100 | len2=100 |

seq2 ==seq1 而且len2==len1  
这个报文携带数据序号100到199，与上一个报文携带的数据序号100到199完全一样，即完全重复，所以应该丢弃这个报文。  

3）重复子报文

序号 | 数据报长度  
-|-
seq2=100 | len2=50 |

seq2 ==seq1 而且len2<len1  
这个报文携带数据序号100~149，说明这是上一个报文的一部分，所以应该丢弃这个报文。  
注：第二、三这两种情况可以合并，即seq2 ==seq1 而且len2<=len1，这里分别列出只是为了说明各种不同情况。

4）部分重复报文情况一

序号 | 数据报长度  
-|-
seq2=150 | len2=30 |

seq2>seq1而且seq2<seq1+len1而且seq2+len2<=seq1+len1  
即这个报文携带序号150到179，这个序号段被包含在上一个报文段中（100到199），所以应该丢弃这个报文。  

5）部分重复报文情况二

序号 | 数据报长度  
-|-
seq2=150 | len2=100 |

seq2>seq1而且seq2<seq1+len1而且seq2+len2>seq1+len1
即这个报文携带序号150~249，这个序号段前一部分150到199被包含在上一个报文段（100到199）中，后一部分200到249是新的数据，此时应该对这个报文作如下处理：

A. 计算重复字节数  
 (seq1+len1) - Seq2= 100+100-150 = 50  
即这个报文段前50个字节是重复的。  

B. 截取报文段新数据  
丢弃这个报文段的前50字节，截取后面的新数据，即只保留字节序号段200~249。  

C.重新设置这个报文段的seq  
seq2 = seq2+50 = 150+50 = 200  

D. 重新设置这个报文段的数据长度   
len2 = len2-50 =100-50=50  

E.重新设置后报文段如下  

序号 | 数据报长度  
-|-
seq2=200 | len2=50 |

即现在这个报文段携带数据序号200~249，正好是上一个报文的后续报文，现在可以将其作为正常报文追加到正常报文队列。  

6）提前到达的报文

序号 | 数据报长度  
-|-
seq2=300 | len2=100 |

seq2>seq1+len1  
这个报文段携带序号300到399的数据，即不是上一个报文100到199的后续报文，而是提前到来的报文，此时应该将这个报文放置到失序报文队列存储起来，以备后续重组使用。  

>这样直到tcp断开这个socket的链接（FIN=1），此时将正常报文队列和失序报文队列中的数据合并起来，完成重组。取出正常报文队列最后一个报文 的seq和len，在失序报文队列中查找属于它的后续报文，该报文是否可以作为正常报文队列的后续报文处理过程同前面1）~5）的分析。

## links
  * [目录](<目录.md>)