# C++数据结构与算法
- [1.简介](#1)
- [2.算法与数据结构实现](#2)
- [3.leetcode记录](#3)
- [4.大话数据结构](#4)
- [5.大话算法](#5)



## <a id="1">1.简介</a>
```cpp
数据结构
线性
  栈
  队列 双端队列 循环队列 优先队列
  散列表 哈希表
  
非线性结构
	二叉树 满二叉树 完全二叉树 二叉树自平衡(红黑树，AVL树，树堆)
	深度优先遍历：前序 中序 后序  广度优先遍历：层序
	二叉堆(最小堆最小在最上面，最大堆最大在最上面。利用完全二叉树交换最后面一个)----可实现优先队列
	
算法
排序算法
	冒泡 选择 插入 希尔O(n2)
	快速 并归 堆 O(nlogn)
	计数 桶 基数 复杂度线性
		冒泡：优化可能后半有序，可设置标志位推出，保存最后一次值下次跳过 起始值跳过。
		鸡尾酒排序：比较交换双向，类似钟摆，先是左到右，后是右到左。减少排序回合，适用大部分有序。
		插入排序：有序和无序，将无序插入有序，进行移位操作。
		选择：选择最大最右，然后最大的放在右边，依次直到排序完成。
		希尔排序：选择上修改，10数增量5-2-1，每5增量形成一组，每组按大小重新挑选成一个数组，然后再按2-1增量拍寻。
		快速排序：分治冒泡，交换排序，选择基准把数分两边，直到不能分。交换有双边和单边循环。双边除基数，头尾两个指针指向数和基数比较，符合分组移动指针，交换值，直到排序完成。
				单边循环有一个指针进行分组
		堆排序：在二叉堆上进行插入，最后输出。
		计数排序：创建最大-最小范围数组，依次找数在对应下标下加1，最后根据数组大小排序。
		桶排序：创建几个分组桶。(最大-最小)/桶数，分组拍寻。
详细可以去ProgramLearnig找。



面试算法
1.判断是否有环：依次遍历比较之前是否有相同值，或者依次放入hash中看重复值，两个指针一个+1一个+2，比较是否相同，类似速度追寻比较。
计算环长：环头依次找到和环头相等值，或者两个指针相差乘以步数相等即环长。
```

排序  

| 排序算法 | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 | 数据对象稳定性 |
| -------- | -------------- | -------------- | ---------- | -------------------- |
| 冒泡排序 | O(n2)          | O(n2)          | O(1)       | 稳定               |
| 选择排序 | O(n2)          | O(n2)          | O(1)       | 数组不稳定、链表稳定 |
| 插入排序 | O(n2)          | O(n2)          | O(1)       | 稳定               |
| 快速排序 | O(n*log2n)     | O(n2)          | O(log2n)   | 不稳定            |
| 堆排序 | O(n*log2n)     | O(n*log2n)     | O(1)       | 不稳定            |
| 归并排序 | O(n*log2n)     | O(n*log2n)     | O(n)       | 稳定               |
| 希尔排序 | O(n*log2n)     | O(n2)          | O(1)       | 不稳定            |
| 计数排序 | O(n+m)         | O(n+m)         | O(n+m)     | 稳定               |
| 桶排序 | O(n)           | O(n)           | O(m)       | 稳定               |
| 基数排序 | O(k*n)         | O(n2)          |            | 稳定               |

均按从小到大排列   
k：代表数值中的 “数位” 个数   
n：代表数据规模   
m：代表数据的最大值减最小值   

查找  

| 查找算法                 | 平均时间复杂度 | 空间复杂度 | 查找条件 | 数据对象稳定性 |
| ---------------------------- | ---------------- | ---------- | ---------- | -------------------- |
| 顺序查找                 | O(n)             | O(1)       | 无序或有序 | 稳定               |
| 二分查找（折半查找） | O(log2n)         | O(1)       | 有序     | 数组不稳定、链表稳定 |
| 插值查找                 | O(log2(log2n))   | O(1)       | 有序     | 稳定               |
| 斐波那契查找           | O(log2n)         | O(1)       | 有序     | 不稳定            |
| 哈希查找                 | O(1)             | O(n)       | 无序或有序 | 不稳定            |
| 二叉查找树（二叉搜索树查找） | O(log2n)         |            |            | 稳定               |
| 红黑树                    | O(log2n)         |            |            | 不稳定            |
| 2-3树                       | O(log2n - log3n) |            |            | 稳定               |
| B树/B+树                   | O(log2n)         |            | B树/B+树 | 稳定               |
|                              |                  |            |            | 稳定               |

图搜索算法   

| 图搜索算法 | 数据结构 | 遍历时间复杂度 | 空间复杂度 |
| --------------- | ---------- | --------------- | ---------- |
| BFS广度优先搜索 | 邻接矩阵 | BFS广度优先搜索 | 邻接矩阵 |
| 邻接链表    | O(|v|2)    | 邻接链表    | O(|v|2)    |
| O(|v|+|E|)      | O(|v|2)    | O(|v|+|E|)      | O(|v|2)    |
| O(|v|+|E|)      | O(|v|+|E|) | O(|v|+|E|)      | O(|v|+|E|) |
| DFS深度优先搜索 | 邻接矩阵 | DFS深度优先搜索 | 邻接矩阵 |
| 邻接链表    | O(|v|2)    | 邻接链表    | O(|v|2)    |
| O(|v|+|E|)      | O(|v|2)    | O(|v|+|E|)      | O(|v|2)    |
| O(|v|+|E|)      | O(|v|+|E|) | O(|v|+|E|)      | O(|v|+|E|) |

其他算法     

| 算法   | 思想                                                                                                             | 应用                                                 |
| -------- | ------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------ |
| 分治法 | 把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并 | 循环赛日程安排问题、排序算法（快速排序、归并排序） |
| 动态规划 | 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题 | 背包问题、斐波那契数列                      |
| 贪心法 | 一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法 | 旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码 |


## <a id="2">2.算法与数据结构实现</a>
- [2.1算法与数据结构实现](#2.1)
- [2.2单向链表基本操作](#2.2)


### <a id="2.1">2.1二叉查找树插入和显示</a>
```cpp
二叉树基本结构：
struct TreeList
{
    int data;
    struct TreeList * p_leftleaf;
    struct TreeList * p_rightleaf;
};
二叉查找树：左边小于根节点，右边大于根节点
插入数据方法：
1.通过调用递归函数方法插入数据，一个个找数据，大于右边或者小于左边并为0则插入左边，否则不为0则递归调用
2.通过一个中间指针循环找出适合插入得根结点，最后插入
显示数据方法：左 中 右 也是递归方法
printf("\n data = %d", p_leaf->data);
ShowTreeDataPre(p_leaf->p_leftleaf);
ShowTreeDataPre(p_leaf->p_rightleaf);
```

### <a id="2.2">2.2单向链表基本操作</a>
```cpp
单向链表基础结构：
truct NodeList
{
    int data;
    struct NodeList * p_next;
};

链表插入数据：找到next尾部为0，在next指向插入malloc数据。

在指定位置插入数据：一次查找到指定位置，p_temp = p_ptr->p_next;p_ptr = p_ptr->p_next;插入数据。
查找数据返回位置：指针一次查找，返回位置
升序或降序排序：两个指针指向，依次指向为非0，比较大小冒泡排序
显示数据：指针依次找为非0，依次打印
删除：指针得指针

while(0 != *p_head)
{
    p_ptr = *p_head;
    *p_head = (*p_head)->p_next;
    free(p_ptr);
}
```

## <a id="3">3.eetcode记录</a>

### 1.求数组中和为目标值得
```cpp
1.暴力法，是依次找和为目标值
2从开头，找目标值-第一个值
3.用key value
4.用这样方式
while (low < high){
    if (numbers[low] + numbers[high] == target){
        result.push_back(low+1);
        result.push_back(high+1);
        return result;
    }else{
        numbers[low] + numbers[high] > target ? high-- : low++;
    }
}
如果是求三个数和，可以安装两个和。或者先排序再计算和。
```

### 2 求数组中最长不含重复字符长度
比如aijhgkab，就是a到a。从第一位开始，计算到末尾出现重复长度，保存最长长度。

### 3 求整形数据反转
比如198 891。198/10 =8，sum = 8*10,依次整除直到为0.while（x!=0）

### 4 求两个有序数组中位数
首先判断两个数组为0情况，计算A数组中间值在B组得位置，如果位置值等于两个数组得和一半，即为中间值。如果不等于一半，需要减少一个值计算中间值。如果位置值大于两个数组和，需要递归计算到正确得中间值。如果位置值小于两个数组之和，需要递归计算到正确中间值。
### 5 最长回文子串
求一个字符串最长回文子串，1232134即为12321长度。方法1从1开始遍历找到下一个相同得。方法2字符串反转再求公共字符串。方法3中心扩展，即一个数前后比较。方法4假设回文长度为1~n进行查找比较是否存在。方法5动态规划法即123321是 2332也是依次。

### 6 字符串进行反转
字符串反转，asdfg变成gfdsa，方法1首尾交换，依次交换即可反转。

### 7正则表达式匹配
匹配正则表达式和是字符串是否相同，.*用指针比较，是否相等。叠加比较。

### 8 计算一系列线段包围最大面积
盛最多水的容器，暴力法从1开始计算面积。

### 9 括号生成
```cpp
方法1暴力法检查是否有效。   
方法2递归
void generator(vector<string>& result, int left, int right, string s){
    if (left==0 && right==0){
        result.push_back(s);
        return;
    }
    if (left>0){
        generator(result, left-1, right, s+'(');
    }
    if (right>0 && right>left){
        generator(result, left, right-1, s+')');
    }
}
```

### 10 移除相同元素
```cpp
排序后进行查找，
int removeElement(vector<int>& nums, int val) {
    int pos = 0;
    for (int i=0; i<nums.size(); i++){
        if (nums[i] != val){
            nums[pos++] = nums[i]; 
        }
    }
    return pos;
}

int removeElement(int A[], int n, int elem) {
    int tail = n-1;
    int i = 0;
    while ( i<=tail ){
        if (A[i]==elem){
            A[i] = A[tail--];
            continue;
        }
        i++;
    }
    return tail+1;
}
将后面的排在后面或者将尾部排在后面
```

### 11 下一个数
1234  1243  
方法1 暴力法  
方法2 一遍扫描  

<img src="./image/7-1.png" style="zoom:100%" />

1往后找到两是下降的4比7小。再往找比4大最接近5交换

### 12 组合总和
计算一个数组中和为目标的总和  

递归法

<img src="./image/7-2.png" style="zoom:100%" />

### 13 缺失的第一个正数
给定一个未排序的整数数组，找出其中没有出现的最小的正整数。方法1 排序之后再查找一下

方法2.桶排序，比较索引上得值，放在合适位置上，到时候比较位置上值和索引值，不合适得即为  
方法3 如果 a ^ b = c ，那么 a ^ c = b 与 b ^ c = a 同时成立，利用这一条，可以用于交换两个变量的值。  

### 14 接雨水
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6

<img src="./image/7-3.png" style="zoom:100%" />

```cpp
方法1 按行求
整个思路就是，求第 i 层的水，遍历每个位置，如果当前的高度小于 i，并且两边有高度大于等于 i 的，说明这个地方一定有水，水就可以加 11。

方法2 按列求
初始化 ans=0ans=0
从左向右扫描数组：
初始化 {max_left}=0max_left=0 和 {max_right}=0max_right=0
从当前元素向左扫描并更新：
{max_left}=\max({max_left},{height}[j])max_left=max(max_left,height[j])
从当前元素向右扫描并更新：
{max_right}=\max({max_right},{height}[j])max_right=max(max_right,height[j])
将\min({max_left},{max_right}) - {height}[i]min(max_left,max_right)−height[i] 累加到 {ans}ans

方法3
找到数组中从下标 i 到最左端最高的条形块高度 {left\_max}left_max。
找到数组中从下标 i 到最右端最高的条形块高度 {right\_max}right_max。

扫描数组 {height}height 并更新答案：
累加 \min({max\_left}[i],{max\_right}[i]) - {height}[i]min(max_left[i],max_right[i])−height[i] 到 ansans 上
```

### 15 跳跃游戏
给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。

方法1 计算每一步内能达到最长长度 ，然后下一步依次到最后一步  
方法2 计算每一步到最后一步最短长度，暴力法  

### 15 图像数组旋转90度
```cpp
方法1 单次循环中旋转 4 个矩形
for( int i=0; i<n/2; i++ ){
    int low=i, high=n-i-1;
    for (int j=low; j<high; j++){
        int tmp;
        tmp = matrix[i][j];
        // left to top 
        matrix[i][j] = matrix[n-j-1][i];
        // bottom to left
        matrix[n-j-1][i] = matrix[n-i-1][n-j-1];
        // right to bottom
        matrix[n-i-1][n-j-1] = matrix[j][n-i-1];
        // top to right
        matrix[j][n-i-1] = tmp;
    }
}
```

### 16 N皇后问题
n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

方法1 依次排除前后下上   
方法2 约束编程 它的基本含义是在放置每个皇后以后增加限制。当在棋盘上放置了一个皇后后，立即排除当前行，列和对应的两个对角线。该过程传递了 约束 从而有助于减少需要考虑情况数。

### 17求数组合并区间
方法1 数组根据start数进行排序进行合并

### 18 旋转链表
输入: 1->2->3->4->5->NULL, k = 2  
输出: 4->5->1->2->3->NULL  
方法1：找到断点k = k%len，然后后面的作为head 前面移到末尾  

### 19 不同路径动态规划
个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？  

```cpp
方法1 动态规划 
vector< vector <int> >  dp (n, vector<int>(m, 1));
    for (int row=1; row<n; row++) {
        for (int col=1; col<m; col++) {
            dp[row][col] = dp[row-1][col] + dp[row][col-1];
        }
    }
return dp[n-1][m-1];

障碍物
如果第一个格点 obstacleGrid[0,0] 是 1，说明有障碍物，那么机器人不能做任何移动，我们返回结果 0。
否则，如果 obstacleGrid[0,0] 是 0，我们初始化这个值为 1 然后继续算法。

遍历第一行，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，设值为 0 ；否则设这个值是前一个节点的值 obstacleGrid[i,j] = obstacleGrid[i,j-1]。
遍历第一列，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，设值为 0 ；否则设这个值是前一个节点的值 obstacleGrid[i,j] = obstacleGrid[i-1,j]。
现在，从 obstacleGrid[1,1] 开始遍历整个数组，如果某个格点初始不包含任何障碍物，就把值赋为上方和左侧两个格点方案数之和 obstacleGrid[i,j] = obstacleGrid[i-1,j] + obstacleGrid[i,j-1]。
如果这个点有障碍物，设值为 0 ，这可以保证不会对后面的路径产生贡献。
```

最小路径和
暴力  

<img src="./image/7-4.png" style="zoom:100%" />

二维动态规划  

<img src="./image/7-5.png" style="zoom:100%" />

### 20 求平方根
```cpp
res = (res + x / res) / 2多执行几次既可以
( 4 + 2/ 4 ) / 2 = 2.25
( 2.25 + 2/ 2.25 ) / 2 = 1.56944..
( 1.56944..+ 2/1.56944..) / 2 = 1.42189..
( 1.42189..+ 2/1.42189..) / 2 = 1.41423..
```

### 21 求路径
/a/./b/../../c/  
利用堆栈的原理去解决  

### 22 编辑距离
给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。  

```cpp
动态规划
//Dynamic Programming
int row, col;
for (row=1; row<m.size(); row++) {
    for(col=1; col<m[row].size(); col++){
        if (word1[row-1] == word2[col-1] ){
            m[row][col] = m[row-1][col-1];
        }else{
            int minValue = min(m[row-1][col-1], m[row-1][col],  m[row][col-1]);
            m[row][col] = minValue + 1;
        }
    }
}
```

<img src="./image/7-6.png" style="zoom:100%" />

### 23 最小覆盖子串
给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。

方法1采用窗口得方法，即用两个指针依次排查，一前一后。  
初始，leftleft指针和rightright指针都指向SS的第一个元素.   
将 rightright 指针右移，扩张窗口，直到得到一个可行窗口，亦即包含TT的全部字母的窗口。得到可行的窗口后，将lefttleftt指针逐个右移，若得到的窗口依然可行，则更新最小窗口大小。若窗口不再可行，则跳转至 22。  

### 24 组合
给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

方法1 依次排列出来  
方法2 利用字典 00011 对应所有数字   

### 25 柱状图中最大的矩形
方法1 暴力法求解  
放法2 分治  

算法
通过观察，可以发现，最大面积矩形存在于以下几种情况：
确定了最矮柱子以后，矩形的宽尽可能往两边延伸。
在最矮柱子左边的最大面积矩形（子问题）。
在最矮柱子右边的最大面积矩形（子问题）。

举个例子：
[6, 4, 5, 2, 4, 3, 9]
这里最矮柱子高度为 2 。以 2 为高的最大子矩阵面积是 2x7=14 。现在，我们考虑上面提到的第二种和第三种情况。我们对高度为 2 柱子的左边和右边采用同样的过程。在 2 的左边， 4 是最小的，形成区域为 4x3=12 。将左边区域再继续分，矩形的面积分别为 6x1=6 和 5x1=5 。同样的，我们可以求出右边区域的面积为 3x3=9, 4x1=4 和 9x1=9 。因此，我们得到最大面积是 16 。

方法3 栈  
在这种方法中，我们维护一个栈。一开始，我们把 -1 放进栈的顶部来表示开始。初始化时，按照从左到右的顺序，我们不断将柱子的序号放进栈中，直到遇到相邻柱子呈下降关系，也就是 a[i-1] > a[i]a[i−1]>a[i] 。现在，我们开始将栈中的序号弹出，直到遇到 stack[j]stack[j] 满足a\big[stack[j]\big] \leq a[i]a[stack[j]]≤a[i] 。每次我们弹出下标时，我们用弹出元素作为高形成的最大面积矩形的宽是当前元素与 stack[top-1]stack[top−1] 之间的那些柱子。也就是当我们弹出 stack[top]stack[top] 时，记当前元素在原数组中的下标为 i ，当前弹出元素为高的最大矩形面积为：

(i-stack[top-1]-1) \times a\big[stack[top]\big].  
(i−stack[top−1]−1)×a[stack[top]].  
更进一步，当我们到达数组的尾部时，我们将栈中剩余元素全部弹出栈。在弹出每一个元素是，我们用下面的式子来求面积： (stack[top]-stack[top-1]) \times a\big[stack[top]\big](stack[top]−stack[top−1])×a[stack[top]]，其中，stack[top]stack[top]表示刚刚被弹出的元素。因此，我们可以通过每次比较新计算的矩形面积来获得最大的矩形面积。  


### 26 格雷编码
格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。  
给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头  

<img src="./image/7-7.png" style="zoom:100%" />

就是在前面依次加 0 1 叠加就可以

### 27 交错字符串
给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。输入: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
输出: true

方法1 暴力法列举所有得可能性  
方法2 利用队列得方法，有相同得取出即可，都没有就报错。  
方法3 动态规划  

### 28 二叉树展开为链表
```cpp
给定一个二叉树，原地将它展开为链表。
*          1
*         / \
*        2   5
*       / \   \
*      3   4   6    

*    1
*     \
*      2
*       \
*        3
*         \
*          4
*           \
*            5
*             \
*              6

方法1 递归依次计算

方法2 
将左子树插入到右子树的地方
将原来的右子树接到左子树的最右边节点
考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null
```

### 29 不同的子序列
```cpp
给定一个字符串 S 和一个字符串 T，计算在 S 的子序列中 T 出现的个数。
一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）

方法1 暴力法
方法2 动态规划 
从0到字符串的长度，即需要一个  dp[ t.size()+1 ] [ s.size()+1 ]  的矩阵。其中，dp[ i ][ j ] 代表当字符串 s 走到 j 位置，字符串 t 走到 i 位置， 有多少次匹配。

其中暴力递归中 
dfs(res, s, t, i, j+1)  对应  dp[ i ][ j ] = dp[ i ][ j-1 ]， 
dfs(res, s, t, i+1, j+1)  对应  dp[ i ][ j ] += dp[ i-1 ][ j-1 ]。
初始化第一行的意义是字符串 s 匹配空字符串的结果， 结果为 1 。
S = "babgbag", T = "bag" 时的 dp 矩阵
```
<img src="./image/7-8.png" style="zoom:100%" />

即遇到相同得计算左边和左边上面和之值，不相同得话保持相同值。

### 30 单词接龙
给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：   

```cpp
每次转换只能改变一个字母。
转换过程中的中间单词必须是字典中的单词。
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]
输出
[
  ["hit","hot","dot","dog","cog"],
  ["hit","hot","lot","log","cog"]
]
利用map或者堆栈进行记录所有路线
```

### 31 分发糖果
老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。你需要按照以下要求，帮助老师给这些孩子分发糖果：  
每个孩子至少分配到 1 个糖果。相邻的孩子中，评分高的孩子必须获得更多的糖果。

方法1 暴力法，先都赋值1 依次比较 增加   
方法2 用两个数组，一个从左，一个从右比较。大于就加1 ，然后两个数组比较，取大的。即满足要求   

### 32 LRU缓存机制
LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。

支持以下操作： 获取数据 get 和 写入数据 put 。  
获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。  
写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。  
就是双向链表 key-vlaue 去除最后一个  

### 33 直线上最多的点数
给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。    
方法 ：暴力查找法   

### 34 逆波兰表达式求值
根据逆波兰表示法，求表达式的值。  
有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。  

### 35 股票买卖
方法1 暴力穷举法   
方法2 现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。   

<img src="./image/7-9.png" style="zoom:100%" />

```cpp
通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
              max(   选择 rest  ,           选择 sell      )

解释：今天我没有持有股票，有两种可能：
要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；
要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
              max(   选择 rest  ,           选择 buy         )

解释：今天我持有着股票，有两种可能：
要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；
要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。

这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。

现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。

dp[-1][k][0] = 0
解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。
dp[-1][k][1] = -infinity
解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。
dp[i][0][0] = 0
解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。
dp[i][0][1] = -infinity
解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。

把上面的状态转移方程总结一下：
base case：
dp[-1][k][0] = dp[i][0][0] = 0
dp[-1][k][1] = dp[i][0][1] = -infinity
状态转移方程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```

### 36 最短回文串
给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。   
示例 1:  
输入: "aacecaaa"  
输出: "aaacecaaa"  

方法1 暴力法找到最短回文字符串然后反转添加头或者尾   
方法2 双指针递归方法  
方法3 kmp Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。即用前缀和后缀进行比较或者进行反转进行比较    

### 37 寻找重复数
给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。  

方法1 排完序之后再找  
方法2 利用key vvlue  
方法3 弗洛伊德的乌龟和兔子（循环检测）  

<img src="./image/7-10.png" style="zoom:100%" />

双指针，两个一个指向index，慢慢比较两个值

### 38 Nim 游戏
你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。   

你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。   
如果堆中石头的数量 nn 不能被 44 整除，那么你总是可以赢得 Nim 游戏的胜利。   

推理   
让我们考虑一些小例子。显而易见的是，如果石头堆中只有一块、两块、或是三块石头，那么在你的回合，你就可以把全部石子拿走，从而在游戏中取胜。而如果就像题目描述那样，堆中恰好有四块石头，你就会失败。因为在这种情况下不管你取走多少石头，总会为你的对手留下几块，使得他可以在游戏中打败你。因此，要想获胜，在你的回合中，必须避免石头堆中的石子数为 4 的情况。

同样地，如果有五块、六块、或是七块石头，你可以控制自己拿取的石头数，总是恰好给你的对手留下四块石头，使他输掉这场比赛。但是如果石头堆里有八块石头，你就不可避免地会输掉，因为不管你从一堆石头中挑出一块、两块还是三块，你的对手都可以选择三块、两块或一块，以确保在再一次轮到你的时候，你会面对四块石头。

显然，它以相同的模式不断重复 n=4,8,12,16,\dotsn=4,8,12,16,…，基本可以看出是 44 的倍数。

### 39数据流的中位数
方法1 将数字存储在可调整大小的容器中。每次需要输出中间值时，对容器进行排序并输出中间值。

方法2 插入排序 保持容易排序  

方法3 用两个堆，保持两个堆平衡  

### 40 判断是否是4的倍数
与01010101比较   

### 41 最大单词长度乘积
给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。  

示例 1:    
输入: ["abcw","baz","foo","bar","xtfn","abcdef"]     
输出: 16    

解释: 这两个单词为 "abcw", "xtfn"。   
方法1 用00000000000  代表每一个字母 然后或一下   

### 42 拼接最大数
给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k <= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。

求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。  

```cpp
示例 1:
输入:
nums1 = [3, 4, 6, 5]
nums2 = [9, 1, 2, 5, 8, 3]
k = 5
输出:
[9, 8, 6, 5, 3]
方法1 依次从两个数组中找到k k-i个数最大数 用一个数组循环从1 到k进行查找比较
```

### 43 求一个二叉树和
```java
public int pathSum(TreeNode root, int sum) {
    if(root == null) return 0;
    return helper(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
}
int helper(TreeNode root, int sum){
    if(root == null) return 0;
    sum -= root.val;
    return (sum == 0 ? 1 : 0) + helper(root.left, sum) + helper(root.right, sum);
}
```

### 44 求一个字符串中匹配子符串
思路1：穷举法，依次比较比较值是否相等。   
思路2：计算每个字母对应得hashcode值，然后比较hash值。可能存在重复值可以用8421位代替，计算值比较大。  

## <a id="4">4.大话数据结构</a>
- [4.1基础](#4.1)
- [4.2线性表](#4.2)
- [4.3栈和队列](#4.3)
- [4.4树](#4.4)
- [4.5图](#4.5)




### <a id="4.1">4.1基础</a>
时间复杂度：选择复杂度最大得。      

<img src="./image/7-11.png" style="zoom:100%" />

### <a id="4.2">4.2线性表</a>
零个或多个数据元素有限序列。   

#### 1.线性表的顺序存储结构
用数组存放数据，支持插入删除等操作，都是前后数据进行操作。优点：可以快速存取元素，缺点：插入删除需要移动大量元素容易造成存储碎片难以确定存储空间容量。   


#### 2.线性表的链式存储结构----单链表
节点node由数据域和指针域组成。   

只包含一个指针域叫单链表。插入需要malloc，删除需要free。删除插入需要找到依次找到相关位置才能插入删除。当不知道位置时候顺序和链式区别不大， 但是链表操作指针比较效率高。  
整表创建一种是头插法，在头插入即将数据插入头和第二个之间。还有一种尾插法，可以找到尾部再插入或者用r临时指针依次插入next再赋值r给需要插入值。  
整表删除一种是删除从头后面临时r得的值，依次删除，先保存r的next地址，再删除r。再赋值。

静态链表是用数组实现，动态链表是指针。指针域是数组下标域。

```c
/*  随机产生n个元素的值，建立带表头结点的单链线性表L（头插法） */
void CreateListHead(LinkList *L, int n) 
{
	LinkList p;
	int i;
	srand(time(0));                         /* 初始化随机数种子 */
	*L = (LinkList)malloc(sizeof(Node));
	(*L)->next = NULL;                      /*  先建立一个带头结点的单链表 */
	for (i=0; i<n; i++) 
	{
		p = (LinkList)malloc(sizeof(Node)); /*  生成新结点 */
		p->data = rand()%100+1;             /*  随机生成100以内的数字 */
		p->next = (*L)->next;    
		(*L)->next = p;						/*  插入到表头 */
	}
}

/*  随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */
void CreateListTail(LinkList *L, int n) 
{
	LinkList p,r;
	int i;
	srand(time(0));                      /* 初始化随机数种子 */
	*L = (LinkList)malloc(sizeof(Node)); /* L为整个线性表 */
	r=*L;                                /* r为指向尾部的结点 */
	for (i=0; i<n; i++) 
	{
		p = (Node *)malloc(sizeof(Node)); /*  生成新结点 */
		p->data = rand()%100+1;           /*  随机生成100以内的数字 */
		r->next=p;                        /* 将表尾终端结点的指针指向新结点 */
		r = p;                            /* 将当前的新结点定义为表尾终端结点 */
	}
	r->next = NULL;                       /* 表示当前链表结束 */
}

/* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */
Status ClearList(LinkList *L)
{ 
	LinkList p,q;
	p=(*L)->next;           /*  p指向第一个结点 */
	while(p)                /*  没到表尾 */
	{
		q=p->next;
		free(p);
		p=q;
	}
	(*L)->next=NULL;        /* 头结点指针域为空 */
	return OK;
}
```

#### 3.线性表的链式存储结构----循环链表
单链表终点指针指向头结点，形成单循环链表。单循环链表可以通过使用尾指针优化速度，rear->next->next和head->next一个意思。

两个循环链表合并

<img src="./image/7-12.png" style="zoom:100%" />

<img src="./image/7-13.png" style="zoom:100%" />

#### 4.线性表的链式存储结构----双向链表
两个指针域一个前驱一个后驱。双向比单向多了反向遍历，但是插入和删除需要更改两个指针。空间替代时间。

<img src="./image/7-14.png" style="zoom:100%" />

<img src="./image/7-15.png" style="zoom:100%" />

最后free(p)

### <a id="4.3">4.3栈和队列</a>
栈是限定仅在表尾插入删除的线性表。      
栈是一段插入另一端删除的线性表。    

#### 1.栈与共享空间
栈，数组+size组成。

可以用两栈共享空间，一个从0开始一个从尾部开始，两端开始向中间聚集。

#### 2.链栈
栈的链式存储结构和实现，栈顶放在链表头部。进栈就是顶点指向新的节点，节点next到原有节点。出栈就是反的顶点指向next，删除原有的。

<img src="./image/7-16.png" style="zoom:100%" />

<img src="./image/7-17.png" style="zoom:100%" />

<img src="./image/7-18.png" style="zoom:100%" />

#### 3.应用
四则运算，遇到右括号就进栈，遇到左括号就出栈，后缀表示法

<img src="./image/7-19.png" style="zoom:100%" />   

<img src="./image/7-20.png" style="zoom:100%" />  

<img src="./image/7-21.png" style="zoom:100%" />  

<img src="./image/7-22.png" style="zoom:100%" />  

#### 4.队列
允许插入的是队尾，删除是对头。线性表有顺序和链式两个，循环链式队列判断满一种是等于设置标志位，一种是（rear+1）%size ==front。 计算队列长度（front-rear +size）%size

```c++
typedef struct QNode	/* 结点结构 */
{
   QElemType data;
   struct QNode *next;
}QNode,*QueuePtr;

typedef struct			/* 队列的链表结构 */
{
   QueuePtr front,rear; /* 队头、队尾指针 */
}LinkQueue;

Status visit(QElemType c)
{
	printf("%d ",c);
	return OK;
}

/* 构造一个空队列Q */
Status InitQueue(LinkQueue *Q)
{ 
	Q->front=Q->rear=(QueuePtr)malloc(sizeof(QNode));
	if(!Q->front)
		exit(OVERFLOW);
	Q->front->next=NULL;
	return OK;
}

/* 销毁队列Q */
Status DestroyQueue(LinkQueue *Q)
{
	while(Q->front)
	{
		 Q->rear=Q->front->next;
		 free(Q->front);
		 Q->front=Q->rear;
	}
	return OK;
}

/* 将Q清为空队列 */
Status ClearQueue(LinkQueue *Q)
{
	QueuePtr p,q;
	Q->rear=Q->front;
	p=Q->front->next;
	Q->front->next=NULL;
	while(p)
	{
		 q=p;
		 p=p->next;
		 free(q);
	}
	return OK;
}

/* 若Q为空队列,则返回TRUE,否则返回FALSE */
Status QueueEmpty(LinkQueue Q)
{ 
	if(Q.front==Q.rear)
		return TRUE;
	else
		return FALSE;
}

/* 求队列的长度 */
int QueueLength(LinkQueue Q)
{ 
	int i=0;
	QueuePtr p;
	p=Q.front;
	while(Q.rear!=p)
	{
		 i++;
		 p=p->next;
	}
	return i;
}

/* 若队列不空,则用e返回Q的队头元素,并返回OK,否则返回ERROR */
Status GetHead(LinkQueue Q,QElemType *e)
{ 
	QueuePtr p;
	if(Q.front==Q.rear)
		return ERROR;
	p=Q.front->next;
	*e=p->data;
	return OK;
}


/* 插入元素e为Q的新的队尾元素 */
Status EnQueue(LinkQueue *Q,QElemType e)
{ 
	QueuePtr s=(QueuePtr)malloc(sizeof(QNode));
	if(!s) /* 存储分配失败 */
		exit(OVERFLOW);
	s->data=e;
	s->next=NULL;
	Q->rear->next=s;	/* 把拥有元素e的新结点s赋值给原队尾结点的后继，见图中① */
	Q->rear=s;		/* 把当前的s设置为队尾结点，rear指向s，见图中② */
	return OK;
}

/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */
Status DeQueue(LinkQueue *Q,QElemType *e)
{
	QueuePtr p;
	if(Q->front==Q->rear)
		return ERROR;
	p=Q->front->next;		/* 将欲删除的队头结点暂存给p，见图中① */
	*e=p->data;				/* 将欲删除的队头结点的值赋值给e */
	Q->front->next=p->next;/* 将原队头结点的后继p->next赋值给头结点后继，见图中② */
	if(Q->rear==p)		/* 若队头就是队尾，则删除后将rear指向头结点，见图中③ */
		Q->rear=Q->front;
	free(p);
	return OK;
}

/* 从队头到队尾依次对队列Q中每个元素输出 */
Status QueueTraverse(LinkQueue Q)
{
	QueuePtr p;
	p=Q.front->next;
	while(p)
	{
		 visit(p->data);
		 p=p->next;
	}
	printf("\n");
	return OK;
}
```

### <a id="4.4">4.4树</a>
#### 基本概念
度是指节点的叶子节点个数。深度是只高度，根节点是1层。
树的存储方式有三种：双亲表示法，孩子表示法，孩子兄弟表示法。

- 双亲表示法   
<img src="./image/7-32.png" style="zoom:100%" />  

<img src="./image/7-33.png" style="zoom:100%" />  

- 孩子表示法   
每个节点可能有多个孩子，每个节点带有多个指针域。   
方案1：   
<img src="./image/7-34.png" style="zoom:100%" />  

缺点：浪费指针域

方案2：   
<img src="./image/7-35.png" style="zoom:100%" />  

- 孩子兄弟表示法
节点有左右节点指针域。类似二叉树。

#### 二叉树
满二叉树，完全二叉树。

<img src="./image/7-36.png" style="zoom:100%" />  

按照满二叉树编号如果缺少就不是完全二叉树，或者从上往下看，缺少得是最下面得左边就是完全二叉树。

- 1.在i层，第i层最多有2^(i-1)-1个节点。    
- 2.深度i，最多有2^i-1个节点。   

<img src="./image/7-38.png" style="zoom:100%" />  

<img src="./image/7-37.png" style="zoom:100%" />  

<img src="./image/7-39.png" style="zoom:100%" />  

<img src="./image/7-40.png" style="zoom:100%" />  

<img src="./image/7-41.png" style="zoom:100%" />  

#### 二叉树存储方式与操作方式
一种是左右节点，一种是数组方式。  

前序遍历：根左右   
中序遍历：左根右   
后序遍历：左右根  
层序遍历：从上往下从左到右。   

<img src="./image/7-42.png" style="zoom:100%" />  

前驱后驱节点由于空指针域导致浪费，所以在遍历得时候修改空指针过程就是线索化。

```c++
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0

#define MAXSIZE 100 /* 存储空间初始分配量 */

typedef int Status;	/* Status是函数的类型,其值是函数结果状态代码,如OK等 */
typedef char TElemType;
typedef enum {Link,Thread} PointerTag;	/* Link==0表示指向左右孩子指针, */
										/* Thread==1表示指向前驱或后继的线索 */
typedef  struct BiThrNode	/* 二叉线索存储结点结构 */
{
	TElemType data;	/* 结点数据 */
	struct BiThrNode *lchild, *rchild;	/* 左右孩子指针 */
	PointerTag LTag;
	PointerTag RTag;		/* 左右标志 */
} BiThrNode, *BiThrTree;

TElemType Nil='#'; /* 字符型以空格符为空 */

Status visit(TElemType e)
{
	printf("%c ",e);
	return OK;
}

/* 按前序输入二叉线索树中结点的值,构造二叉线索树T */
/* 0(整型)/空格(字符型)表示空结点 */
Status CreateBiThrTree(BiThrTree *T)
{ 
	TElemType h;
	scanf("%c",&h);

	if(h==Nil)
		*T=NULL;
	else
	{
		*T=(BiThrTree)malloc(sizeof(BiThrNode));
		if(!*T)
			exit(OVERFLOW);
		(*T)->data=h; /* 生成根结点(前序) */
		CreateBiThrTree(&(*T)->lchild); /* 递归构造左子树 */
		if((*T)->lchild) /* 有左孩子 */
			(*T)->LTag=Link;
		CreateBiThrTree(&(*T)->rchild); /* 递归构造右子树 */
		if((*T)->rchild) /* 有右孩子 */
			(*T)->RTag=Link;
	}
	return OK;
}

BiThrTree pre; /* 全局变量,始终指向刚刚访问过的结点 */
/* 中序遍历进行中序线索化 */
void InThreading(BiThrTree p)
{ 
	if(p)
	{
		InThreading(p->lchild); /* 递归左子树线索化 */
		if(!p->lchild) /* 没有左孩子 */
		{
			p->LTag=Thread; /* 前驱线索 */
			p->lchild=pre; /* 左孩子指针指向前驱 */
		}
		if(!pre->rchild) /* 前驱没有右孩子 */
		{
			pre->RTag=Thread; /* 后继线索 */
			pre->rchild=p; /* 前驱右孩子指针指向后继(当前结点p) */
		}
		pre=p; /* 保持pre指向p的前驱 */
		InThreading(p->rchild); /* 递归右子树线索化 */
	}
}

/* 中序遍历二叉树T,并将其中序线索化,Thrt指向头结点 */
Status InOrderThreading(BiThrTree *Thrt,BiThrTree T)
{ 
	*Thrt=(BiThrTree)malloc(sizeof(BiThrNode));
	if(!*Thrt)
		exit(OVERFLOW);
	(*Thrt)->LTag=Link; /* 建头结点 */
	(*Thrt)->RTag=Thread;
	(*Thrt)->rchild=(*Thrt); /* 右指针回指 */
	if(!T) /* 若二叉树空,则左指针回指 */
		(*Thrt)->lchild=*Thrt;
	else
	{
		(*Thrt)->lchild=T;
		pre=(*Thrt);
		InThreading(T); /* 中序遍历进行中序线索化 */
		pre->rchild=*Thrt;
		pre->RTag=Thread; /* 最后一个结点线索化 */
		(*Thrt)->rchild=pre;
	}
	return OK;
}

/* 中序遍历二叉线索树T(头结点)的非递归算法 */
Status InOrderTraverse_Thr(BiThrTree T)
{ 
	BiThrTree p;
	p=T->lchild; /* p指向根结点 */
	while(p!=T)
	{ /* 空树或遍历结束时,p==T */
		while(p->LTag==Link)
			p=p->lchild;
		if(!visit(p->data)) /* 访问其左子树为空的结点 */
			return ERROR;
		while(p->RTag==Thread&&p->rchild!=T)
		{
			p=p->rchild;
			visit(p->data); /* 访问后继结点 */
		}
		p=p->rchild;
	}
	return OK;
}

int main()
{
	BiThrTree H,T;
	printf("请按前序输入二叉树(如:'ABDH##I##EJ###CF##G##')\n");
 	CreateBiThrTree(&T); /* 按前序产生二叉树 */
	InOrderThreading(&H,T); /* 中序遍历,并中序线索化二叉树 */
	printf("中序遍历(输出)二叉线索树:\n");
	InOrderTraverse_Thr(H); /* 中序遍历(输出)二叉线索树 */
	printf("\n");
	
	return 0;
}
```

#### 森林、树、二叉树之间转换

<img src="./image/7-43.png" style="zoom:100%" />  

<img src="./image/7-44.png" style="zoom:100%" />  

<img src="./image/7-45.png" style="zoom:100%" />  

<img src="./image/7-46.png" style="zoom:100%" />  

<img src="./image/7-47.png" style="zoom:100%" />  

<img src="./image/7-48.png" style="zoom:100%" />  

### <a id="4.5">4.5图</a>
<img src="./image/7-55.png" style="zoom:100%" />  

<img src="./image/7-56.png" style="zoom:100%" />  

无向图指没有方向得，有向图有方向<A，B>。无向n个顶点，n(n-1)/2个边。有向n个顶点，n(n-1)个边。如果边或者顶点加权重，可以称为网。对于无向图，边数就是各顶点度数和得一半。有向图各个顶点入和出顶点数相等。

<img src="./image/7-57.png" style="zoom:100%" />  

## <a id="5">5.大话算法</a>
- [5.1模式匹配算法](#5.1)
- [5.2赫夫曼算法](#5.2)


### <a id="5.1">5.1模式匹配算法</a>
- [5.1.1朴素模式匹配算法](#5.1.1)
- [5.1.2KMP模式匹配算法](#5.1.2)

#### <a id="5.1.1">5.1.1朴素模式匹配算法</a>
比较两个字符串是否相等，朴素模式匹配算法：  

<img src="./image/7-23.png" style="zoom:100%" />  

```c++
/* 返回子串T在主串S中第pos个字符之后的位置。若不存在,则函数返回值为0。 */
/* 其中,T非空,1≤pos≤StrLength(S)。 */
int Index(String S, String T, int pos) 
{
	int i = pos;	/* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */
	int j = 1;				/* j用于子串T中当前位置下标值 */
	while (i <= S[0] && j <= T[0]) /* 若i小于S的长度并且j小于T的长度时，循环继续 */
	{
		if (S[i] == T[j]) 	/* 两字母相等则继续 */
      	{
			++i;
         	++j; 
      	} 
      	else 				/* 指针后退重新开始匹配 */
      	{  
         	i = i-j+2;		/* i退回到上次匹配首位的下一位 */
         	j = 1; 			/* j退回到子串T的首位 */
      	}      
	}
	if (j > T[0]) 
		return i-T[0];
	else 
		return 0;
}
```

#### <a id="5.1.2">5.1.2KMP模式匹配算法</a>
参考链接：  
1.从头到尾彻底理解KMP   
https://www.cnblogs.com/zhangtianq/p/5839909.html    

思路：

总结就是比较abcdefg  abcdg。由于g和e不等，a又和bcd不等，所有不需要判断，直接右移四位。进行a和e比较进行。后面依次。  
先计算出next数组，再计算出移动位置。改进得方法去除aaaax aaab比较。直接移动到x。

失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值

- 1.移动实列：  
<img src="./image/7-24.png" style="zoom:100%" />  

- 2.next数组计算公式：  
<img src="./image/7-25.png" style="zoom:100%" />  

- 3.计算子字符串公共字符串公式：  
<img src="./image/7-29.png" style="zoom:100%" />  

- 4.子字符串公共字符串与next数组关系：  
<img src="./image/7-31.png" style="zoom:100%" />  

- 5.next数组实列：  
<img src="./image/7-26.png" style="zoom:100%" />  

- 6.移动实列：  
<img src="./image/7-30.png" style="zoom:100%" />  


>改良版：   

<img src="./image/7-27.png" style="zoom:100%" />  

<img src="./image/7-28.png" style="zoom:100%" />  

```c
假设现在文本串S（母符串）匹配到 i 位置，模式串P（子符串）匹配到 j 位置.
	如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；
	如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，
	模式串P相对于文本串S向右移动了j - next [j] 位。
		换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值（next 
		数组的求解会在下文的3.3.3节中详细阐述），即移动的实际位数为：j - next[j]，且此值大于等于1。  

int KmpSearch(char* s, char* p)  
{  
    int i = 0;  
    int j = 0;  
    int sLen = strlen(s);  
    int pLen = strlen(p);  
    while (i < sLen && j < pLen)  
    {  
        //①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++      
        if (j == -1 || s[i] == p[j])  
        {  
            i++;  
            j++;  
        }  
        else  
        {  
            //②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]      
            //next[j]即为j所对应的next值        
            j = next[j];  
        }  
    }  
    if (j == pLen)  
        return i - j;  
    else  
        return -1;  
}  

正常版本：
/* 通过计算返回子串T的next数组。 */
void get_next(String T, int *next) 
{
	int i,j;
  	i=1;
  	j=0;
  	next[1]=0;
  	while (i<T[0])  /* 此处T[0]表示串T的长度 */
 	{
    	if(j==0 || T[i]== T[j]) 	/* T[i]表示后缀的单个字符，T[j]表示前缀的单个字符 */
		{
      		++i;  
			++j;  
			next[i] = j;
    	} 
		else 
			j= next[j];	/* 若字符不相同，则j值回溯 */
  	}
}

/* 返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。 */
/*  T非空，1≤pos≤StrLength(S)。 */
int Index_KMP(String S, String T, int pos) 
{
	int i = pos;		/* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */
	int j = 1;			/* j用于子串T中当前位置下标值 */
	int next[255];		/* 定义一next数组 */
	get_next(T, next);	/* 对串T作分析，得到next数组 */
	while (i <= S[0] && j <= T[0]) /* 若i小于S的长度并且j小于T的长度时，循环继续 */
	{
		if (j==0 || S[i] == T[j]) 	/* 两字母相等则继续，与朴素算法增加了j=0判断 */
      	{
         	++i;
         	++j; 
      	} 
      	else 			/* 指针后退重新开始匹配 */
      	 	j = next[j];/* j退回合适的位置，i值不变 */
	}
	if (j > T[0]) 
		return i-T[0];
	else 
		return 0;
}

改良版本：
/* 求模式串T的next函数修正值并存入数组nextval */
void get_nextval(String T, int *nextval) 
{
  	int i,j;
  	i=1;
  	j=0;
  	nextval[1]=0;
  	while (i<T[0])  /* 此处T[0]表示串T的长度 */
 	{
    	if(j==0 || T[i]== T[j]) 	/* T[i]表示后缀的单个字符，T[j]表示前缀的单个字符 */
		{
      		++i;  
			++j;  
			if (T[i]!=T[j])      /* 若当前字符与前缀字符不同 */
				nextval[i] = j;	/* 则当前的j为nextval在i位置的值 */
      		else 
				nextval[i] = nextval[j];	/* 如果与前缀字符相同，则将前缀字符的 */
											/* nextval值赋值给nextval在i位置的值 */
    	} 
		else 
			j= nextval[j];			/* 若字符不相同，则j值回溯 */
  	}
}
int Index_KMP1(String S, String T, int pos) 
{
	int i = pos;		/* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */
	int j = 1;			/* j用于子串T中当前位置下标值 */
	int next[255];		/* 定义一next数组 */
	get_nextval(T, next);	/* 对串T作分析，得到next数组 */
	while (i <= S[0] && j <= T[0]) /* 若i小于S的长度并且j小于T的长度时，循环继续 */
	{
		if (j==0 || S[i] == T[j]) 	/* 两字母相等则继续，与朴素算法增加了j=0判断 */
      	{
         	++i;
         	++j; 
      	} 
      	else 			/* 指针后退重新开始匹配 */
      	 	j = next[j];/* j退回合适的位置，i值不变 */
	}
	if (j > T[0]) 
		return i-T[0];
	else 
		return 0;
}
```

### <a id="5.2">5.2赫夫曼算法</a>
压缩编码算法，类似文件压缩。举例就是分数转换成良好优秀等级。

<img src="./image/7-49.png" style="zoom:100%" />  

带权路径长度wpl最小得二叉树叫赫夫曼树。即使都是赫夫曼树也是有结构差异，有效率差异。

<img src="./image/7-50.png" style="zoom:100%" />  

<img src="./image/7-51.png" style="zoom:100%" />  

<img src="./image/7-52.png" style="zoom:100%" />  

#### 编码实列
<img src="./image/7-53.png" style="zoom:100%" />  

<img src="./image/7-54.png" style="zoom:100%" />  

## links
  * [目录](<目录.md>)