# C++数据结构与算法
- [1.简介](#1)
- [2.算法与数据结构实现](#2)
- [3.leetcode记录](#3)

## <a id="1">1.简介</a>
```cpp
数据结构
线性
  栈
  队列 双端队列 循环队列 优先队列
  散列表 哈希表
  
非线性结构
	二叉树 满二叉树 完全二叉树 二叉树自平衡(红黑树，AVL树，树堆)
	深度优先遍历：前序 中序 后序  广度优先遍历：层序
	二叉堆(最小堆最小在最上面，最大堆最大在最上面。利用完全二叉树交换最后面一个)----可实现优先队列
	
算法
排序算法
	冒泡 选择 插入 希尔O(n2)
	快速 并归 堆 O(nlogn)
	计数 桶 基数 复杂度线性
		冒泡：优化可能后半有序，可设置标志位推出，保存最后一次值下次跳过 起始值跳过。
		鸡尾酒排序：比较交换双向，类似钟摆，先是左到右，后是右到左。减少排序回合，适用大部分有序。
		插入排序：有序和无序，将无序插入有序，进行移位操作。
		选择：选择最大最右，然后最大的放在右边，依次直到排序完成。
		希尔排序：选择上修改，10数增量5-2-1，每5增量形成一组，每组按大小重新挑选成一个数组，然后再按2-1增量拍寻。
		快速排序：分治冒泡，交换排序，选择基准把数分两边，直到不能分。交换有双边和单边循环。双边除基数，头尾两个指针指向数和基数比较，符合分组移动指针，交换值，直到排序完成。
				单边循环有一个指针进行分组
		堆排序：在二叉堆上进行插入，最后输出。
		计数排序：创建最大-最小范围数组，依次找数在对应下标下加1，最后根据数组大小排序。
		桶排序：创建几个分组桶。(最大-最小)/桶数，分组拍寻。
详细可以去ProgramLearnig找。



面试算法
1.判断是否有环：依次遍历比较之前是否有相同值，或者依次放入hash中看重复值，两个指针一个+1一个+2，比较是否相同，类似速度追寻比较。
计算环长：环头依次找到和环头相等值，或者两个指针相差乘以步数相等即环长。
```

排序  

| 排序算法 | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 | 数据对象稳定性 |
| -------- | -------------- | -------------- | ---------- | -------------------- |
| 冒泡排序 | O(n2)          | O(n2)          | O(1)       | 稳定               |
| 选择排序 | O(n2)          | O(n2)          | O(1)       | 数组不稳定、链表稳定 |
| 插入排序 | O(n2)          | O(n2)          | O(1)       | 稳定               |
| 快速排序 | O(n*log2n)     | O(n2)          | O(log2n)   | 不稳定            |
| 堆排序 | O(n*log2n)     | O(n*log2n)     | O(1)       | 不稳定            |
| 归并排序 | O(n*log2n)     | O(n*log2n)     | O(n)       | 稳定               |
| 希尔排序 | O(n*log2n)     | O(n2)          | O(1)       | 不稳定            |
| 计数排序 | O(n+m)         | O(n+m)         | O(n+m)     | 稳定               |
| 桶排序 | O(n)           | O(n)           | O(m)       | 稳定               |
| 基数排序 | O(k*n)         | O(n2)          |            | 稳定               |

均按从小到大排列   
k：代表数值中的 “数位” 个数   
n：代表数据规模   
m：代表数据的最大值减最小值   

查找  

| 查找算法                 | 平均时间复杂度 | 空间复杂度 | 查找条件 | 数据对象稳定性 |
| ---------------------------- | ---------------- | ---------- | ---------- | -------------------- |
| 顺序查找                 | O(n)             | O(1)       | 无序或有序 | 稳定               |
| 二分查找（折半查找） | O(log2n)         | O(1)       | 有序     | 数组不稳定、链表稳定 |
| 插值查找                 | O(log2(log2n))   | O(1)       | 有序     | 稳定               |
| 斐波那契查找           | O(log2n)         | O(1)       | 有序     | 不稳定            |
| 哈希查找                 | O(1)             | O(n)       | 无序或有序 | 不稳定            |
| 二叉查找树（二叉搜索树查找） | O(log2n)         |            |            | 稳定               |
| 红黑树                    | O(log2n)         |            |            | 不稳定            |
| 2-3树                       | O(log2n - log3n) |            |            | 稳定               |
| B树/B+树                   | O(log2n)         |            | B树/B+树 | 稳定               |
|                              |                  |            |            | 稳定               |

图搜索算法   

| 图搜索算法 | 数据结构 | 遍历时间复杂度 | 空间复杂度 |
| --------------- | ---------- | --------------- | ---------- |
| BFS广度优先搜索 | 邻接矩阵 | BFS广度优先搜索 | 邻接矩阵 |
| 邻接链表    | O(|v|2)    | 邻接链表    | O(|v|2)    |
| O(|v|+|E|)      | O(|v|2)    | O(|v|+|E|)      | O(|v|2)    |
| O(|v|+|E|)      | O(|v|+|E|) | O(|v|+|E|)      | O(|v|+|E|) |
| DFS深度优先搜索 | 邻接矩阵 | DFS深度优先搜索 | 邻接矩阵 |
| 邻接链表    | O(|v|2)    | 邻接链表    | O(|v|2)    |
| O(|v|+|E|)      | O(|v|2)    | O(|v|+|E|)      | O(|v|2)    |
| O(|v|+|E|)      | O(|v|+|E|) | O(|v|+|E|)      | O(|v|+|E|) |

其他算法     

| 算法   | 思想                                                                                                             | 应用                                                 |
| -------- | ------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------ |
| 分治法 | 把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并 | 循环赛日程安排问题、排序算法（快速排序、归并排序） |
| 动态规划 | 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题 | 背包问题、斐波那契数列                      |
| 贪心法 | 一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法 | 旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码 |


## <a id="2">2.算法与数据结构实现</a>
- [2.1算法与数据结构实现](#2.1)
- [2.2单向链表基本操作](#2.2)


### <a id="2.1">2.1二叉查找树插入和显示</a>
```cpp
二叉树基本结构：
struct TreeList
{
    int data;
    struct TreeList * p_leftleaf;
    struct TreeList * p_rightleaf;
};
二叉查找树：左边小于根节点，右边大于根节点
插入数据方法：
1.通过调用递归函数方法插入数据，一个个找数据，大于右边或者小于左边并为0则插入左边，否则不为0则递归调用
2.通过一个中间指针循环找出适合插入得根结点，最后插入
显示数据方法：左 中 右 也是递归方法
printf("\n data = %d", p_leaf->data);
ShowTreeDataPre(p_leaf->p_leftleaf);
ShowTreeDataPre(p_leaf->p_rightleaf);
```

### <a id="2.2">2.2单向链表基本操作</a>
```cpp
单向链表基础结构：
truct NodeList
{
    int data;
    struct NodeList * p_next;
};

链表插入数据：找到next尾部为0，在next指向插入malloc数据。

在指定位置插入数据：一次查找到指定位置，p_temp = p_ptr->p_next;p_ptr = p_ptr->p_next;插入数据。
查找数据返回位置：指针一次查找，返回位置
升序或降序排序：两个指针指向，依次指向为非0，比较大小冒泡排序
显示数据：指针依次找为非0，依次打印
删除：指针得指针

while(0 != *p_head)
{
    p_ptr = *p_head;
    *p_head = (*p_head)->p_next;
    free(p_ptr);
}
```

## <a id="3">3.eetcode记录</a>

### 1.求数组中和为目标值得
```cpp
1.暴力法，是依次找和为目标值
2从开头，找目标值-第一个值
3.用key value
4.用这样方式
while (low < high){
    if (numbers[low] + numbers[high] == target){
        result.push_back(low+1);
        result.push_back(high+1);
        return result;
    }else{
        numbers[low] + numbers[high] > target ? high-- : low++;
    }
}
如果是求三个数和，可以安装两个和。或者先排序再计算和。
```

### 2 求数组中最长不含重复字符长度
比如aijhgkab，就是a到a。从第一位开始，计算到末尾出现重复长度，保存最长长度。

### 3 求整形数据反转
比如198 891。198/10 =8，sum = 8*10,依次整除直到为0.while（x!=0）

### 4 求两个有序数组中位数
首先判断两个数组为0情况，计算A数组中间值在B组得位置，如果位置值等于两个数组得和一半，即为中间值。如果不等于一半，需要减少一个值计算中间值。如果位置值大于两个数组和，需要递归计算到正确得中间值。如果位置值小于两个数组之和，需要递归计算到正确中间值。
### 5 最长回文子串
求一个字符串最长回文子串，1232134即为12321长度。方法1从1开始遍历找到下一个相同得。方法2字符串反转再求公共字符串。方法3中心扩展，即一个数前后比较。方法4假设回文长度为1~n进行查找比较是否存在。方法5动态规划法即123321是 2332也是依次。

### 6 字符串进行反转
字符串反转，asdfg变成gfdsa，方法1首尾交换，依次交换即可反转。

### 7正则表达式匹配
匹配正则表达式和是字符串是否相同，.*用指针比较，是否相等。叠加比较。

### 8 计算一系列线段包围最大面积
盛最多水的容器，暴力法从1开始计算面积。

### 9 括号生成
```cpp
方法1暴力法检查是否有效。   
方法2递归
void generator(vector<string>& result, int left, int right, string s){
    if (left==0 && right==0){
        result.push_back(s);
        return;
    }
    if (left>0){
        generator(result, left-1, right, s+'(');
    }
    if (right>0 && right>left){
        generator(result, left, right-1, s+')');
    }
}
```

### 10 移除相同元素
```cpp
排序后进行查找，
int removeElement(vector<int>& nums, int val) {
    int pos = 0;
    for (int i=0; i<nums.size(); i++){
        if (nums[i] != val){
            nums[pos++] = nums[i]; 
        }
    }
    return pos;
}

int removeElement(int A[], int n, int elem) {
    int tail = n-1;
    int i = 0;
    while ( i<=tail ){
        if (A[i]==elem){
            A[i] = A[tail--];
            continue;
        }
        i++;
    }
    return tail+1;
}
将后面的排在后面或者将尾部排在后面
```

### 11 下一个数
1234  1243  
方法1 暴力法  
方法2 一遍扫描  

<img src="./image/7-1.png" style="zoom:100%" />

1往后找到两是下降的4比7小。再往找比4大最接近5交换

### 12 组合总和
计算一个数组中和为目标的总和  

递归法

<img src="./image/7-2.png" style="zoom:100%" />

### 13 缺失的第一个正数
给定一个未排序的整数数组，找出其中没有出现的最小的正整数。方法1 排序之后再查找一下

方法2.桶排序，比较索引上得值，放在合适位置上，到时候比较位置上值和索引值，不合适得即为  
方法3 如果 a ^ b = c ，那么 a ^ c = b 与 b ^ c = a 同时成立，利用这一条，可以用于交换两个变量的值。  

### 14 接雨水
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6

<img src="./image/7-3.png" style="zoom:100%" />

```cpp
方法1 按行求
整个思路就是，求第 i 层的水，遍历每个位置，如果当前的高度小于 i，并且两边有高度大于等于 i 的，说明这个地方一定有水，水就可以加 11。

方法2 按列求
初始化 ans=0ans=0
从左向右扫描数组：
初始化 {max_left}=0max_left=0 和 {max_right}=0max_right=0
从当前元素向左扫描并更新：
{max_left}=\max({max_left},{height}[j])max_left=max(max_left,height[j])
从当前元素向右扫描并更新：
{max_right}=\max({max_right},{height}[j])max_right=max(max_right,height[j])
将\min({max_left},{max_right}) - {height}[i]min(max_left,max_right)−height[i] 累加到 {ans}ans

方法3
找到数组中从下标 i 到最左端最高的条形块高度 {left\_max}left_max。
找到数组中从下标 i 到最右端最高的条形块高度 {right\_max}right_max。

扫描数组 {height}height 并更新答案：
累加 \min({max\_left}[i],{max\_right}[i]) - {height}[i]min(max_left[i],max_right[i])−height[i] 到 ansans 上
```

### 15 跳跃游戏
给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。

方法1 计算每一步内能达到最长长度 ，然后下一步依次到最后一步  
方法2 计算每一步到最后一步最短长度，暴力法  

### 15 图像数组旋转90度
```cpp
方法1 单次循环中旋转 4 个矩形
for( int i=0; i<n/2; i++ ){
    int low=i, high=n-i-1;
    for (int j=low; j<high; j++){
        int tmp;
        tmp = matrix[i][j];
        // left to top 
        matrix[i][j] = matrix[n-j-1][i];
        // bottom to left
        matrix[n-j-1][i] = matrix[n-i-1][n-j-1];
        // right to bottom
        matrix[n-i-1][n-j-1] = matrix[j][n-i-1];
        // top to right
        matrix[j][n-i-1] = tmp;
    }
}
```

### 16 N皇后问题
n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

方法1 依次排除前后下上   
方法2 约束编程 它的基本含义是在放置每个皇后以后增加限制。当在棋盘上放置了一个皇后后，立即排除当前行，列和对应的两个对角线。该过程传递了 约束 从而有助于减少需要考虑情况数。

### 17求数组合并区间
方法1 数组根据start数进行排序进行合并

### 18 旋转链表
输入: 1->2->3->4->5->NULL, k = 2  
输出: 4->5->1->2->3->NULL  
方法1：找到断点k = k%len，然后后面的作为head 前面移到末尾  

### 19 不同路径动态规划
个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？  

```cpp
方法1 动态规划 
vector< vector <int> >  dp (n, vector<int>(m, 1));
    for (int row=1; row<n; row++) {
        for (int col=1; col<m; col++) {
            dp[row][col] = dp[row-1][col] + dp[row][col-1];
        }
    }
return dp[n-1][m-1];

障碍物
如果第一个格点 obstacleGrid[0,0] 是 1，说明有障碍物，那么机器人不能做任何移动，我们返回结果 0。
否则，如果 obstacleGrid[0,0] 是 0，我们初始化这个值为 1 然后继续算法。

遍历第一行，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，设值为 0 ；否则设这个值是前一个节点的值 obstacleGrid[i,j] = obstacleGrid[i,j-1]。
遍历第一列，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，设值为 0 ；否则设这个值是前一个节点的值 obstacleGrid[i,j] = obstacleGrid[i-1,j]。
现在，从 obstacleGrid[1,1] 开始遍历整个数组，如果某个格点初始不包含任何障碍物，就把值赋为上方和左侧两个格点方案数之和 obstacleGrid[i,j] = obstacleGrid[i-1,j] + obstacleGrid[i,j-1]。
如果这个点有障碍物，设值为 0 ，这可以保证不会对后面的路径产生贡献。
```

最小路径和
暴力  

<img src="./image/7-4.png" style="zoom:100%" />

二维动态规划  

<img src="./image/7-5.png" style="zoom:100%" />

### 20 求平方根
```cpp
res = (res + x / res) / 2多执行几次既可以
( 4 + 2/ 4 ) / 2 = 2.25
( 2.25 + 2/ 2.25 ) / 2 = 1.56944..
( 1.56944..+ 2/1.56944..) / 2 = 1.42189..
( 1.42189..+ 2/1.42189..) / 2 = 1.41423..
```

### 21 求路径
/a/./b/../../c/  
利用堆栈的原理去解决  

### 22 编辑距离
给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。  

```cpp
动态规划
//Dynamic Programming
int row, col;
for (row=1; row<m.size(); row++) {
    for(col=1; col<m[row].size(); col++){
        if (word1[row-1] == word2[col-1] ){
            m[row][col] = m[row-1][col-1];
        }else{
            int minValue = min(m[row-1][col-1], m[row-1][col],  m[row][col-1]);
            m[row][col] = minValue + 1;
        }
    }
}
```

<img src="./image/7-6.png" style="zoom:100%" />

### 23 最小覆盖子串
给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。

方法1采用窗口得方法，即用两个指针依次排查，一前一后。  
初始，leftleft指针和rightright指针都指向SS的第一个元素.   
将 rightright 指针右移，扩张窗口，直到得到一个可行窗口，亦即包含TT的全部字母的窗口。得到可行的窗口后，将lefttleftt指针逐个右移，若得到的窗口依然可行，则更新最小窗口大小。若窗口不再可行，则跳转至 22。  

### 24 组合
给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

方法1 依次排列出来  
方法2 利用字典 00011 对应所有数字   

### 25 柱状图中最大的矩形
方法1 暴力法求解  
放法2 分治  

算法
通过观察，可以发现，最大面积矩形存在于以下几种情况：
确定了最矮柱子以后，矩形的宽尽可能往两边延伸。
在最矮柱子左边的最大面积矩形（子问题）。
在最矮柱子右边的最大面积矩形（子问题）。

举个例子：
[6, 4, 5, 2, 4, 3, 9]
这里最矮柱子高度为 2 。以 2 为高的最大子矩阵面积是 2x7=14 。现在，我们考虑上面提到的第二种和第三种情况。我们对高度为 2 柱子的左边和右边采用同样的过程。在 2 的左边， 4 是最小的，形成区域为 4x3=12 。将左边区域再继续分，矩形的面积分别为 6x1=6 和 5x1=5 。同样的，我们可以求出右边区域的面积为 3x3=9, 4x1=4 和 9x1=9 。因此，我们得到最大面积是 16 。

方法3 栈  
在这种方法中，我们维护一个栈。一开始，我们把 -1 放进栈的顶部来表示开始。初始化时，按照从左到右的顺序，我们不断将柱子的序号放进栈中，直到遇到相邻柱子呈下降关系，也就是 a[i-1] > a[i]a[i−1]>a[i] 。现在，我们开始将栈中的序号弹出，直到遇到 stack[j]stack[j] 满足a\big[stack[j]\big] \leq a[i]a[stack[j]]≤a[i] 。每次我们弹出下标时，我们用弹出元素作为高形成的最大面积矩形的宽是当前元素与 stack[top-1]stack[top−1] 之间的那些柱子。也就是当我们弹出 stack[top]stack[top] 时，记当前元素在原数组中的下标为 i ，当前弹出元素为高的最大矩形面积为：

(i-stack[top-1]-1) \times a\big[stack[top]\big].  
(i−stack[top−1]−1)×a[stack[top]].  
更进一步，当我们到达数组的尾部时，我们将栈中剩余元素全部弹出栈。在弹出每一个元素是，我们用下面的式子来求面积： (stack[top]-stack[top-1]) \times a\big[stack[top]\big](stack[top]−stack[top−1])×a[stack[top]]，其中，stack[top]stack[top]表示刚刚被弹出的元素。因此，我们可以通过每次比较新计算的矩形面积来获得最大的矩形面积。  


### 26 格雷编码
格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。  
给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头  

<img src="./image/7-7.png" style="zoom:100%" />

就是在前面依次加 0 1 叠加就可以

### 27 交错字符串
给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。输入: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
输出: true

方法1 暴力法列举所有得可能性  
方法2 利用队列得方法，有相同得取出即可，都没有就报错。  
方法3 动态规划  

### 28 二叉树展开为链表
```cpp
给定一个二叉树，原地将它展开为链表。
*          1
*         / \
*        2   5
*       / \   \
*      3   4   6    

*    1
*     \
*      2
*       \
*        3
*         \
*          4
*           \
*            5
*             \
*              6

方法1 递归依次计算

方法2 
将左子树插入到右子树的地方
将原来的右子树接到左子树的最右边节点
考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null
```

### 29 不同的子序列
```cpp
给定一个字符串 S 和一个字符串 T，计算在 S 的子序列中 T 出现的个数。
一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）

方法1 暴力法
方法2 动态规划 
从0到字符串的长度，即需要一个  dp[ t.size()+1 ] [ s.size()+1 ]  的矩阵。其中，dp[ i ][ j ] 代表当字符串 s 走到 j 位置，字符串 t 走到 i 位置， 有多少次匹配。

其中暴力递归中 
dfs(res, s, t, i, j+1)  对应  dp[ i ][ j ] = dp[ i ][ j-1 ]， 
dfs(res, s, t, i+1, j+1)  对应  dp[ i ][ j ] += dp[ i-1 ][ j-1 ]。
初始化第一行的意义是字符串 s 匹配空字符串的结果， 结果为 1 。
S = "babgbag", T = "bag" 时的 dp 矩阵
```
<img src="./image/7-8.png" style="zoom:100%" />

即遇到相同得计算左边和左边上面和之值，不相同得话保持相同值。

### 30 单词接龙
给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：   

```cpp
每次转换只能改变一个字母。
转换过程中的中间单词必须是字典中的单词。
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]
输出
[
  ["hit","hot","dot","dog","cog"],
  ["hit","hot","lot","log","cog"]
]
利用map或者堆栈进行记录所有路线
```

### 31 分发糖果
老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。你需要按照以下要求，帮助老师给这些孩子分发糖果：  
每个孩子至少分配到 1 个糖果。相邻的孩子中，评分高的孩子必须获得更多的糖果。

方法1 暴力法，先都赋值1 依次比较 增加   
方法2 用两个数组，一个从左，一个从右比较。大于就加1 ，然后两个数组比较，取大的。即满足要求   

### 32 LRU缓存机制
LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。

支持以下操作： 获取数据 get 和 写入数据 put 。  
获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。  
写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。  
就是双向链表 key-vlaue 去除最后一个  

### 33 直线上最多的点数
给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。    
方法 ：暴力查找法   

### 34 逆波兰表达式求值
根据逆波兰表示法，求表达式的值。  
有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。  

### 35 股票买卖
方法1 暴力穷举法   
方法2 现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。   

<img src="./image/7-9.png" style="zoom:100%" />

```cpp
通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
              max(   选择 rest  ,           选择 sell      )

解释：今天我没有持有股票，有两种可能：
要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；
要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
              max(   选择 rest  ,           选择 buy         )

解释：今天我持有着股票，有两种可能：
要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；
要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。

这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。

现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。

dp[-1][k][0] = 0
解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。
dp[-1][k][1] = -infinity
解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。
dp[i][0][0] = 0
解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。
dp[i][0][1] = -infinity
解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。

把上面的状态转移方程总结一下：
base case：
dp[-1][k][0] = dp[i][0][0] = 0
dp[-1][k][1] = dp[i][0][1] = -infinity
状态转移方程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```

### 36 最短回文串
给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。   
示例 1:  
输入: "aacecaaa"  
输出: "aaacecaaa"  

方法1 暴力法找到最短回文字符串然后反转添加头或者尾   
方法2 双指针递归方法  
方法3 kmp Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。即用前缀和后缀进行比较或者进行反转进行比较    

### 37 寻找重复数
给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。  

方法1 排完序之后再找  
方法2 利用key vvlue  
方法3 弗洛伊德的乌龟和兔子（循环检测）  

<img src="./image/7-10.png" style="zoom:100%" />

双指针，两个一个指向index，慢慢比较两个值

### 38 Nim 游戏
你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。   

你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。   
如果堆中石头的数量 nn 不能被 44 整除，那么你总是可以赢得 Nim 游戏的胜利。   

推理   
让我们考虑一些小例子。显而易见的是，如果石头堆中只有一块、两块、或是三块石头，那么在你的回合，你就可以把全部石子拿走，从而在游戏中取胜。而如果就像题目描述那样，堆中恰好有四块石头，你就会失败。因为在这种情况下不管你取走多少石头，总会为你的对手留下几块，使得他可以在游戏中打败你。因此，要想获胜，在你的回合中，必须避免石头堆中的石子数为 4 的情况。

同样地，如果有五块、六块、或是七块石头，你可以控制自己拿取的石头数，总是恰好给你的对手留下四块石头，使他输掉这场比赛。但是如果石头堆里有八块石头，你就不可避免地会输掉，因为不管你从一堆石头中挑出一块、两块还是三块，你的对手都可以选择三块、两块或一块，以确保在再一次轮到你的时候，你会面对四块石头。

显然，它以相同的模式不断重复 n=4,8,12,16,\dotsn=4,8,12,16,…，基本可以看出是 44 的倍数。

### 39数据流的中位数
方法1 将数字存储在可调整大小的容器中。每次需要输出中间值时，对容器进行排序并输出中间值。

方法2 插入排序 保持容易排序  

方法3 用两个堆，保持两个堆平衡  

### 40 判断是否是4的倍数
与01010101比较   

### 41 最大单词长度乘积
给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。  

示例 1:    
输入: ["abcw","baz","foo","bar","xtfn","abcdef"]     
输出: 16    

解释: 这两个单词为 "abcw", "xtfn"。   
方法1 用00000000000  代表每一个字母 然后或一下   

### 42 拼接最大数
给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k <= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。

求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。  

```cpp
示例 1:
输入:
nums1 = [3, 4, 6, 5]
nums2 = [9, 1, 2, 5, 8, 3]
k = 5
输出:
[9, 8, 6, 5, 3]
方法1 依次从两个数组中找到k k-i个数最大数 用一个数组循环从1 到k进行查找比较
```

### 43 求一个二叉树和
```java
public int pathSum(TreeNode root, int sum) {
    if(root == null) return 0;
    return helper(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
}
int helper(TreeNode root, int sum){
    if(root == null) return 0;
    sum -= root.val;
    return (sum == 0 ? 1 : 0) + helper(root.left, sum) + helper(root.right, sum);
}
```

### 44 求一个字符串中匹配子符串
思路1：穷举法，依次比较比较值是否相等。   
思路2：计算每个字母对应得hashcode值，然后比较hash值。可能存在重复值可以用8421位代替，计算值比较大。   

## links
  * [目录](<目录.md>)